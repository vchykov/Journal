{
    "posts": [
        {
            "date": "2023-07-12",
            "status": "successful",
            "title": "Minimum Depth of Binary Tree",
            "text": "Пошук мінімальної глибини бінарного дерева. Обхід по дереву можливий за алгоритмами DFS (Depth-first search) та BFS (Breadth-first search). Мінімальна глибина бінарного дерева це відстань від кореня до найближчого листка (це вузел без нащадків). У цій проблемі, з огляду на швідкість пошуку рішення, краще використати BFS."
        },
        {
            "date": "2023-07-13",
            "status": "fail",
            "title": "Check if Object Instance of Class",
            "text": "Напишіть функцію, яка перевіряє, чи дане значення є екземпляром даного класу або суперкласу. Для цієї проблеми об’єкт вважається екземпляром даного класу, якщо цей об’єкт має доступ до методів цього класу. <br/> Цікава проблема, вбудованого instanceof недостатньо. В алгоритмі перевірки використовується конструктор об'єкта."
        },
        {
            "date": "2023-07-14",
            "status": "successful",
            "title": "Longest Arithmetic Subsequence of Given Difference",
            "text": "Не одразу зрозуміло що саме треба шукати. Це не підрядок. Підпослідовність це як окремі елементи з похідного масиву, які тільки у тому самому порядку йдуть, та відповідають заданим умовам.<br/> У цій проблемі це - різниця - ціле число на яке зростають/зменшуються числа у підпослідовності. Треба повернути довжину найбільшої підпослідовності."
        },
        {
            "date": "2023-07-15",
            "status": "successful",
            "title": "All Nodes Distance K in Binary Tree",
            "text": "Маючи корінь бінарного дерева, значення цільового вузла та ціле число k, поверніть масив значень усіх вузлів, які мають відстань k від цільового вузла. #cut Цікава проблема, яку не зовсім зрозуміло як вирішувати. Є найпростіший спосіб з додаванням зворотних зв'язків з батьківським елементом для зворотнього руху по дереву, але цей підхід вважається поганою практикою. Рекомендують робити всеспрямований граф і вже з ним працювати. Почати з target-елемента рекурсивно викликати BFS з передаванням глибини на 1 менше. І так доки глибина не дійде до нуля. Знайдені елементи заносятся до масиву результата."
        },
        {
            "date": "2023-07-16",
            "status": "successful",
            "title": "Binary Tree Inorder Traversal",
            "text": "Даний корінь бінарного дерева, поверніть упорядкований обхід значень його вузлів.  #cut Ця проблема легкого рівня. Більш детально розглядаю варіанти обходу дерева. <br/> Існують такі варіанти: <br/>&nbsp - прямий порядок; <br/>&nbsp - зворотній порядок; <br/>&nbsp - симетричний порядок;             <br/>&nbsp - зворотньо-симетричний порядок. <br/> Варіант обходу залежить від послідовності виклику лівого та правого піддерева, а також звернення до батьківського елементу. "
        },
        {
            "date": "2023-07-17",
            "status": "successful",
            "title": "Add Two Numbers II",
            "text": "У цьому завданні надано два непорожніх пов’язаних списка, що представляють два цілі невід’ємні числа. Найстарша цифра йде першою, і кожен з їхніх вузлів містить одну цифру. Додайте два числа та поверніть суму у вигляді зв’язаного списку. #cut Треба порахувати суму ніби у стовпчик, але кожне число то одно-спрямований список (не масив). Завдання вирішено з використанням допоміжних стеків для обох списків, тому що обхід та формування суми треба розпочинати з наймолодших цифр."
        },
        {
            "date": "2023-07-18",
            "status": "successful",
            "title": "LRU Cache",
            "text": "Створіть структуру даних, яка відповідає характеристикам кешу, що останнім часом використовувався (LRU). #cut Тут ідея в тому, що кеш має якийсь ліміт за розміром, тому спочатку він наповнюється елементами, потім треба, перед додаванням нового елементу, знайти який з попередніх був довше за усіх непотрібний, та видалити його. <br/> У реалізації алгоритму використаний об'єкт Map (асоціативний масив). Кожного разу, коли йде звернення до кешу, послідовність елементів змінюється. Той елемент, до якого був доступ чи новий доданий переміщується у кінець кешу. Коли кеш набуває лімітованого розміру, тоді додатково на початку кешу буде видалятися 'найстаріший' елемент, коли треба додати новий елемент."
        },
        {
            "date": "2023-07-19",
            "status": "successful",
            "title": "Non-overlapping Intervals",
            "text": "Інтервали, що не перекриваються. Дано масив інтервалів intervals, де intervals[i] = [start_i, end_i], поверніть мінімальну кількість інтервалів, які потрібно видалити, щоб решта інтервалів не перекривалася. #cut Проблема medium-рівня, яку одразу і не зрозуміло як вирішувати. Подивився editorial. Це відома проблема інтервального планування, яка дуже часто зустрічається у програмуванні та добре описана. <br/>      Проблема максимізації інтервального планування (ISMP) полягає в тому, щоб знайти найбільший сумісний набір, тобто набір непересічних інтервалів максимального розміру. Мета тут полягає в тому, щоб виконати якомога більше завдань, тобто максимізувати пропускну здатність. Це еквівалентно знаходженню максимального незалежного набору в інтервальному графі.<br/>                            Алгоритм який запропонований досить простий. Інтервали спочатку сортуються по часу закінчення за зростанням. Потім у циклі шукається найкоротші інтервали, які ідуть без перекривання, усі інші які перекриваються, рахуються та їх сума повертаються у вигляді відповіді."
        },
        {
            "date": "2023-07-20",
            "status": "successful",
            "title": "Asteroid Collision",
            "text": "Зіткнення астероїдів. Нам надано масив астероїдів цілих чисел, що представляють астероїди в рядку. Для кожного астероїда абсолютне значення представляє його розмір, а знак — його напрямок (позитивне означає праворуч, негативне значення — ліворуч).  #cut Кожен астероїд рухається з однаковою швидкістю. Дізнайтеся стан астероїдів після всіх зіткнень. Якщо два астероїди зустрінуться, менший з них вибухне. Якщо обидва мають однаковий розмір, обидва вибухнуть. Два астероїди, що рухаються в одному напрямку, ніколи не зустрінуться.  <br>       Цікава проблема. Я не став нічого вигадувати і подивися editorial. Дуже хитрий алгоритм. Рішення полягає у роботі з допоміжним масивом або стеком, до якого заносяться ті астероїди, що слід обробити. Далі вони послідовно порівнюються з іншими астероїдами та визначається чи залишится він у стеку або він 'вибухне'. Кожен астероїд порівнюється з кожним іншим рівно один раз. Після цього результуючий стек чи масив вважається готовим."
        },
        {
            "date": "2023-07-21",
            "status": "problem",
            "title": "Number of Longest Increasing Subsequence",
            "text": "Кількість найдовших зростаючих підпослідовностей.<br/>               Перш ніж спробувати вирішити цю задачу, дуже рекомендують, спочатку розв’язати найдовшу зростаючу підпослідовність, до якої ця задача є продовженням. Але я з нею ще не стикався. Рішення я подивився в editorial, так і не зрозумів його, та просто переписав наведений код у JS."
        },
        {
            "date": "2023-07-22",
            "status": "successful",
            "title": "Find the Index of the First Occurrence in a String",
            "text": "Знайдти індекс першого входження в рядок.<br/> Дано два рядки needle і haystack, поверніть індекс першого входження needle у haystack або -1, якщо needle не є частиною haystack. #cut Звичайно у JS є метод string.prototype.indexOf(subStr).Але схоже треба зробити свою реалізацію. Я написав, потім ще трохи переробив алгоритм, але мабуть не зовсім те що треба.                                    Орієнтуватися треба на такі оптимальні алгоритми:                                                                     <br/> &nbsp - <a class='font-bold underline' href='http://en.wikipedia.org/wiki/Boyer-Moore_string_search_algorithm'> Boyer-Moore</a> uses a bad character table with a good suffix table.                                                   <br/> &nbsp - <a class='font-bold underline' href='http://en.wikipedia.org/wiki/Boyer-Moore-Horspool_algorithm'> Boyer-Moore-Horspool</a> uses a bad character table.                                                                   <br/> &nbsp - <a class='font-bold underline' href='http://en.wikipedia.org/wiki/Knuth-Morris-Pratt_algorithm'> Knuth-Morris-Pratt</a> uses a partial match table.                                                                     <br/> &nbsp - <a class='font-bold underline' href='http://en.wikipedia.org/wiki/Rabin-Karp_string_search_algorithm'> Rabin-Karp</a> uses running hashes                                                                                    <br/>Спробував реалізувати Boyer-Moore-Horspool, але схоже що він краще працює на C ніж yf JS."
        },
        {
            "date": "2023-07-24",
            "status": "successful",
            "title": "Merge Two Sorted Lists",
            "text": "Вам надано заголовки двох відсортованих пов’язаних списків list1 і list2. Об’єднайте два списки в один відсортований список. Список має бути створений шляхом з’єднання вузлів перших двох списків. Поверніть заголовок об’єднаного зв’язаного списку. #cut Є реалізація, але дуже повільна і пам'ять жере. Треба зробити якось без new. Подивився як роблять інші - різні підходи є. Мені сподобався варіант де просто з двох списків формується один результуючий, при цьому нові вузли не створюються."
        },
        {
            "date": "2023-07-25",
            "status": "successful",
            "title": "Merge k Sorted Lists",
            "text": "Вам надано масив із k зв’язаних списків, кожен зв’язаний список відсортований у порядку зростання. Об’єднайте всі зв’язані списки в один відсортований зв’язаний список і поверніть його. Проблема рівня hard #cut Спробував зробити для k списків приблизно за учорашнім алгоритмом, але попередньо сортуючи списки за значенням val перших елементів. Працює, але ну дуже повільно. Дуже багато разів іде сортування. Подивився що у інших, який там самий швидкий алгоритм. Виявилося, що можна було всі елементи списків запушити у масив (елемент масива це об'єкт з полями val та next). Потім цей весь масив один раз сортується за значеннями val. Потім цей масив перетворюється у список. При цьому правильно виставляються поля next у кожного елемента з масиву. У фіналі оформлюється tail, та повертається нульовий елемент масиву (як head)."
        },
        {
            "date": "2023-07-26",
            "status": "successful",
            "title": "Merge Sorted Array",
            "text": "Задача об'єднати два неубиваючі масиви розміром m+n та n. У першому масиві останні n елементів заповнені 0. #cut Задачу спочатку вирішив як найпростіше - другий скопіював у кінець першого, а потім відсортував. Але це не оптимальний підхід. <br/> Щоб складність була O(m + n) треба піти іншим шляхом. Почати с кінця першого масива формувати одразу відсортований, шляхом порівняння елементів з першого та другого масивів. Таким шляхом за один прохід по масиву буде сформовано результуючий неубиваючий масив."
        },
        {
            "date": "2023-07-27",
            "status": "problem",
            "title": "Maximum Running Time of N Computers",
            "text": "Максимальний час роботи N комп’ютерів - задача на разрахунок максимального часу n ноутбуків від m (m >= n) батарей акумуляторів. Треба прорахувати на скільки вистачить усіх батарей якщо їх швидко замінювати у комп'ютерах. Ввважається що час заміни невідчутно малий. #cut Задача цікава, особливо від час блекаутів) Я початку спробував просто вирахувати загальну кількість годин роботи (заряду) зі всіх батарей, та розділити на кількість комп'бтерів, результат окриглив до меншого цілого. Але тест кейси деякі не проходили. Стало ясно що не завжди можливо замінити батарею, тому треба якось перевіряти чи можнаа так розставити батареї, щоб усі компи одночасно працювали. Подивився editorial, там якій не дуже зрозумілі підходи та алгоритми, повторити які не вдалося, бо там використовувся тип long, а у мене в JS викидало помилку. <br/> Але коли я почав дивитися просто чиїсь готові рішення мене вразило, на скільки просто ця задача розв'язувалася. Дуже просте рішеня полягало в тому, що спочатку масив з батареями сортували, потім у циклі робили перевірку, якщо ємність одної з батареї перевищувала середню ємність на один комп'ютер, то таку батерею відкидали (із масиву) і комп'ютер в якому вона буде працювати теж, та перераховували середню ємність на компьютер. І так до тих пір, поки  ємність останньої батареї не стає рівною або менше за перераховану середню ємність. Саме її і слід повернути як результат."
        },
        {
            "date": "2023-07-28",
            "status": "fail",
            "title": "Predict the Winner",
            "text": "Вам надано цілочисельний масив nums. Два гравці грають у гру з цим масивом: гравець 1 і гравець 2. Гравець 1 і гравець 2 по черзі, причому гравець 1 починає першим. Обидва гравці починають гру з результатом 0. Кожного ходу гравець бере одне з чисел з обох кінців масиву (тобто nums[0] або nums[nums.length - 1]), що зменшує розмір масиву на 1. Гравець додає вибране число до свого рахунку.  #cut Гра закінчується, коли в масиві більше немає елементів. Поверніть true, якщо Гравець 1 може виграти гру. Якщо бали обох гравців однакові, тоді гравець 1 все ще є переможцем, і ви також повинні повернути true. Ви можете припустити, що обидва гравці грають оптимально.<br/> Завдання medium рівня. І я не знав як робити. Подивився в editorial. Перші два підходи спробував запустити. Другий більш оптимальний, тому що часткові результати обчислень зберігаються у кеші. Сама ідея у тому, що рекурсивно викликається функцція maxDiff(), яка обчислює скільки балів отримає гравець на рахунок. При цьому звісно 'гравець точно розраховує скількі балів він отримує в кінці гри, та робить тільки вигідний для нього хід'. Отже maxDiff отримує два аргументи left та right - це індекси з початку та кінця масиву. А у середені функції обчислюється обидва варіанти ходу та знову викликається для обох варіантів maxDiff. Рекурсія припиняється коли масив з балами звужується до одного числа. Але схоже, що цей алгоритм я так і не зрозумів. Логіка мені до кінця не зрозуміла."
        },
        {
            "date": "2023-07-29",
            "status": "problem",
            "title": "Maximum Product Subarray",
            "text": "Максимальний підмасив добутку. Дано цілочисельний масив nums, знайти підмасив із найбільшим добутком і повернути добуток. Тестові приклади генеруються таким чином, що відповідь поміщається в 32-розрядне ціле число. #cut Цікава задача, я її вирішив і знову геть не оптимально. Подивився, що люди пропонують. І той варіант мені сподобався. За один прохід (O(n)) результат обчислюється. Треба було пройти по масиву, обчислюючи поточний максимум та поточний мінімум (для від'ємних результатів). Вони також використовуються для обчислення самих себе але при наступній ітерації. Якщо поточний максимум перевищить загальний результат, то загальний результат переприсвоюється."
        },
        {
            "date": "2023-07-31",
            "status": "successful",
            "title": "Add Two Numbers",
            "text": "Вам надано два непорожніх пов’язаних списку, що представляють два цілі невід’ємні числа. Цифри зберігаються у зворотному порядку, і кожен їх вузол містить одну цифру. Додайте два числа та поверніть суму у вигляді зв’язаного списку. Ви можете припустити, що два числа не містять жодного початкового нуля, окрім самого числа 0. #cut Ця задача подібна до Add Two Nunbers II, але в чомусь навіть простіша. Проходимо по двом спискам одночасно та формуємо третій - результат. Після того як досягли кінця обох списків, треба звернути увагу на перенос. Повертаємо завчасно збережений вказівник на початок результуючого списку."
        },
        {
            "date": "2023-08-02",
            "status": "successful",
            "title": "Plus One",
            "text": "Вам надано велике ціле число, представлене у вигляді цілого масиву цифр, де кожна цифра[i] є i-ю цифрою цілого числа. Цифри впорядковані від найбільш значущих до найменш значущих у порядку зліва направо. Велике ціле число не містить початкових нулів. #cut Збільште велике ціле число на одиницю та поверніть отриманий масив цифр.<br/> Приклади:<br/>Input: digits = [1,2,3]<br/>Output: [1,2,4]<br/>Input: digits = [4,3,2,1]<br/>Output: [4,3,2,2]<br/>Input: digits = [9]<br/>Output: [1,0]Обмеження:<br/>&nbsp - 1 <= digits.length <= 100<br/>&nbsp - 0 <= digits[i] <= 9<br/>&nbsp - digits не містить початкових нулів.<br/>Пропоную таке рішення. Ідемо з кінця масиву. Якщо там спочатку йде 9 або кілька 9-ок підряд, то їх перезаписуємо на 0. Коли дійдемо до першої цифри яка не дорівнює 9, то просто додамо до цього числа 1. А якщо там взагалі всі 9-ки у вхідному масиві, то треба додати елемент з 1 напочатку масиву."
        },
        {
            "date": "2023-08-03",
            "status": "successful",
            "title": "Add Binary",
            "text": "Дано два двійкові рядки a і b, повернути їх суму як двійковий рядок.<br/>Приклади:<br/>    Input: a = '11', b = '1'<br/>Output: '100'<br/>Input: a = '1010', b = '1011'<br/>Output: '10101' #cut Обмеження:<br/>&nbsp - 1 <= a.length, b.length <= 10^4<br/>&nbsp - a і b складаються лише з символів «0» або «1».<br/>&nbsp - Кожен рядок не містить початкових нулів, за винятком самого нуля.<br/>    Моє рішення просте. Ідемо з кінця одночасно по обом рядкам та знаходимо суму по кожному розряду. Також прораховується перенос. Якщо обидва рядки скінчились, а у переносі є одиниця, то вона записується у найвищий розряд."
        },
        {
            "date": "2023-08-05",
            "status": "fail",
            "title": "Word Break",
            "text": "Дано рядок s і словник рядків wordDict, поверніть true, якщо s можна сегментувати на розділену пробілами послідовність одного або кількох словникових слів. Зауважте, що одне й те саме слово в словнику може використовуватися кілька разів у сегментації. #cut Подивився в editorial. Перший підхід - BFS пошук вширш. Тут будується дерево варіантів як можна скласти строку s з тих слів, що є в wordDict. Переписав наведену реалізацію з Java у JavaScript. Для алгоритму треба було структуру даних типу черга (queue), реалізацію такого класу узяв з інтернету. Непогане рішення вийшло, але часова складність алгоритму O(n^3 + m*k).<br/> Існують більш оптимальні методи рішення цієї задачі."
        },
        {
            "date": "2023-08-06",
            "status": "successful",
            "title": "Reverse Integer",
            "text": "Дано 32-розрядне ціле число x зі знаком, повернути x зі реверсованими цифрами. Якщо реверсування x призводить до того, що значення виходить за межі 32-розрядного цілого діапазону зі знаком [-2^31, 2^31 - 1], поверніть 0. Припустімо, що середовище не дозволяє зберігати 64-розрядні цілі числа (зі знаком або без нього). #cut Так, у JS числа зберігаються у безпечному діапазоні ±(2^53 - 1), тому треба відстежувати виход із цих меж.<br/> Отож, спочатку беремо абсолютне значення, реверсуємо його, потім перевіряємо результат на перевищення дозволеного ліміту і на останок додаємо знак мінуса, якщо дане чило було від'ємним. Можна також зробити ланцюжок split-reverse-join. "
        },
        {
            "date": "2023-08-08",
            "status": "successful",
            "title": "Palindrome Number",
            "text": "Дано ціле число x, поверніть true, якщо x є паліндромом, і false в іншому випадку. #cut Це легка задача, вирішив шляхом конвертації у строку, знаходження середини та проходу у циклі з порівнянням з кінця та з початку.<br/>  У Solutions пропонують варіант без конвертації у строку, а замість цього просто реверсується х. Це роблять знаходженням залишку від поділу на 10, та подальшого поділу на 10 числа x у циклі. З залишків поділу, які кожного разу помножуються на 10, формується реверсоване число."
        },
        {
            "date": "2023-08-09",
            "status": "fail",
            "title": "Valid Number",
            "text": "Треба перевірити надану зміну s чи вона є валідним числом та повернути true або false. Задача hard-рівня, яку я не зміг самостійно вирішити. Подивився в solutions. Перше рішення, що я побачив, сподобалось, тому що сам хотів щось таке написати.  #cut Отже, для рішення цієї проблеми ми повинні скласти список можливих умов помилок та тоді перевірити кожний з них. <br/> Умови помилок:  <br/>&nbsp - Більш ніж один символ ('e'/'E'), або зустрічання 'e'/'E' коли число ще не зустрілося. <br/>&nbsp - Більш ніж один знак, або знак, який з'явлється після коми чи числа. Це скасовується після проходження 'e'/'E'. <br/>&nbsp - Більш ніж одна кома або кома, яка з'являється після зустрічання 'e'/'E'. <br/>&nbsp - Зустрічання будь-яких інших нецифрових символів. <br/>&nbsp - Досягнення кінця s без активного числа.<br/>     Щоб було зручніше, ми можемо встановити прапорці для відстеження різних речей (num, exp, sign, dec). Ми будемо також пам'ятати скидати усі прапорці, окрім exp, коли ми зустрінемо 'e'/'E', оскільки ми починаємо новий цілочислений вираз.<br/> Також є варіант рішення у один рядок, але там використовується приведення типів. Можна наприклад s поділити на 1 та порівняти з s."
        },
        {
            "date": "2023-08-10",
            "status": "successful",
            "title": "Path Crossing",
            "text": "Дано рядковий шлях, де path[i] = 'N', 'S', 'E' або 'W', кожен з яких представляє переміщення на одну одиницю на північ, південь, схід або захід відповідно. Ви починаєте з початку координат (0, 0) на 2D площині та йдете по шляху, визначеному path. Поверніть true, якщо шлях перетинає сам себе в будь-якій точці, тобто якщо в будь-який час ви перебуваєте в місці, яке відвідали раніше. В іншому випадку поверніть false. #cut Обмеження: <br/>&nbsp - 1 <= path.length <= 10^4 <br/>&nbsp - path[i] is either 'N', 'S', 'E', or 'W'. <br/>  Вирішив, але мабуть це не дуже оптимальний по швидкості алгоритм. Кожний хід я записую у сет (у вигляді рядку 'x,y'). Перед записом, перевіряю, чи була вже ця точка відвідана. Якщо так - повертаємо false."
        },
        {
            "date": "2023-08-11",
            "status": "successful",
            "title": "Valid Parentheses",
            "text": "Дано рядок s, який містить лише символи '(', ')', '{', '}', '[' та ']', визначити, чи введений рядок дійсний.  #cut Вхідний рядок дійсний, якщо: відкриті дужки повинні бути закриті дужками того самого типу.  <br/>  Відкриті дужки повинні бути закриті в правильному порядку. Кожна закрита дужка має відповідну відкриту дужку такого ж типу. <br/>  Наприклад: <br/> Вхід: s = '()[]{}' <br/>   Вихід: true <br/> Вхід: s = '(]' <br/>  Вихід: false <br/> Обмеження: <br/>&nbsp - 1 <= s.length <= 10^4 <br/>&nbsp - s складається тільки з дужок '()[]{}'. <br/> Задача Easy-рівня. У циклі проходимо кожний символ. Якщо дужка відкривається, то кладемо її у стек. Якщо закривається, то дістаємо елемент зі стеку і порівнюємо: якщо дужка відповідна, то добре, ідемо далі, а якщо ні - повертаємо false. Якщо дійдемо до кінця строки, то треба перевірити чи пустий стек. Повертаємо true якщо пустий та false, якщо - ні."
        },
        {
            "date": "2023-08-12",
            "status": "successful",
            "title": "Generate Parentheses",
            "text": "Дано n пар дужок, напишіть функцію для генерування всіх комбінацій правильно сформованих дужок. #cut Наприклад: <br/> Вхід: n = 3 <br/> Вихід: ['((()))','(()())','(())()','()(())','()()()'] <br/> Обмеження: <br/>&nbsp - 1 <= n <= 8  <br/>  Так, задача не важка, вирішив самостійно. Ідея у тому, що кожен наступний символ це '(' або ')'. Тому можна рекурсивно одразу для двох випадків формувати наступний символ.  <br/>  Я написав функцію gen(str, n, parenthesesDepth), де str - строка що формується, n - кількість невідкритих дужок та parenthesesDepth - кількіть відкритих дужок. <br/>  Під час кожного виклику цієї функції, якщо це можливо, викликається знову gen з '(', та gen з ')'. Якщо лічильнтки невідкритих та закритих дужок обидва стануть рівними 0, то сфомована строка вноситься у масив результатів."
        },
        {
            "date": "2023-08-13",
            "status": "successful",
            "title": "Letter Combinations of a Phone Number",
            "text": "Дано рядок, що містить цифри від 2 до 9 включно, повертає всі можливі комбінації букв, які може представляти число. Поверніть відповідь у довільному порядку. Відображення цифр і літер (так само, як на кнопках телефону) подано нижче. Зауважте, що 1 не відповідає жодній букві. #cut Наприклад: <br/> Вхід: цифри = '23' <br/> Вихід: ['ad','ae','af','bd','be','bf','cd','ce','cf'] <br/> Обмеження: <br/>&nbsp - 0 <= digits.length <= 4 <br/>&nbsp - digits[i] is a digit in the range ['2', '9']. <br/>  Цю задачу вдалось вирішити самостійно. Спочатку складаємо таблицю відповідностей, де кожній цифрі відповідає масив букв. Потім рекурсивно генеруємо усі можливі послідовності. Беремо першу цифру, знаходимо відповідні букви і для кожної викликаємо рекусію з наступною цифрою. Коли послідовність цифр завершується рекурсія припиняється. а сформовані строки записуються до масиву результатів."
        },
        {
            "date": "2023-08-14",
            "status": "problem",
            "title": "Permutations",
            "text": "Дано масив nums різних цілих чисел, повернути всі можливі перестановки. Ви можете повернути відповідь у будь-якому порядку. #cut \n### Обмеження: \n* `1 <= nums.length <= 6` \n* `-10 <= nums[i] <= 10` \n* Усі цілі числа nums є унікальними. \n *** \n  Не зміг я сам вирішити цю задачу, дивися editorial. \n У алгоритмі використовується рекурсія. Ідея в тому, що наступний елемент послідовності може бути будь-яким елементом, окрім тих елементів, які вже використані в поточній послідовності. Кожен наступний елемент це результат наступного рекурсивного виклику. Коли всі елементи використані, результуюча послідовність записується до масиву результатів."
        },
        {
            "date": "2023-08-15",
            "status": "problem",
            "title": "Next Permutation",
            "text": "Дано масив цілих чисел `nums`, знайти наступну перестановку `nums`.Заміна має бути на місці та використовувати лише постійну додаткову пам’ять. #cut Перестановка масиву цілих чисел — це розміщення його членів у послідовності або лінійному порядку. \n Наприклад, для `arr = [1,2,3]` наступні перестановки `arr: [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1].` \n Наступна перестановка масиву цілих чисел є наступною лексикографічно більшою перестановкою його цілого числа. Більш формально, якщо всі перестановки масиву відсортовані в одному контейнері відповідно до їх лексикографічного порядку, то наступна перестановка цього масиву є перестановкою, яка слідує за ним у відсортованому контейнері. Якщо таке розташування неможливе, масив потрібно перевпорядкувати в найнижчому можливому порядку (тобто відсортувати в порядку зростання). \n Наприклад, наступною перестановкою `arr = [1,2,3] є [1,3,2]`. \n Аналогічно, наступна перестановка `arr = [2,3,1]` є `[3,1,2]`.  \n Тоді як наступною перестановкою `arr = [3,2,1]` є `[1,2,3]`, оскільки `[3,2,1]` не має лексикографічного більшого перегрупування. \n *** \n> Щоб вирішити цю задачу, довелось підгледіти статтю на вікіпедії про перестановки. В editorial той самий підхід. За їхнім алгоритмом написав функцію, яка робить наступну перестановку у лексикографічному порядку.  \n Алгоритм дій: \n 1. Знайти найбільший індекс `k` такий, що `a[k] < a[k + 1]`. Якщо такого індексу не існує, перестановка є останньою (а тому послідовність треба повністтю обернути).  \n 2. Знайти найбільший індекс `l`, більший за `k`, такий, що `a[k] < a[l]`. \n 3. Замінити значення `a[k]` на значення `a[l]`.  \n 4. Обернути послідовність від `a[k + 1]` до кінцевого елемента `a[n]` включно."
        },
        {
            "date": "2023-08-16",
            "status": "problem",
            "title": "Remove Element",
            "text": "Дано цілочисельний масив `nums` і ціле число `val`, видалити всі входження `val` у `nums` на місці. Порядок елементів може бути змінений.  #cut Потім поверніть кількість елементів у `nums`, які не дорівнюють `val`.  \n Розглянемо кількість елементів у `nums`, які не дорівнюють `val`, `k`. Щоб бути прийнятими, вам потрібно зробити наступне: \n* Змініть масив `nums` так, щоб перші `k` елементів `nums` містили елементи, які не дорівнюють `val`. Решта елементів `nums` не важливі, як і розмір `nums`. \n* Поверніть k. \n *** \n Написав своє рішення з заміною елементів на велике число, та подальшим сортуванням. Але воно неоптимальне. Подивився Solutions. Там усього за один прохід формується потрібний масив на місці. Фактично кожний елемент перезаписується але за індексом, якому дорівнює лічильник елементів, які не дорівнюють `val`."
        },
        {
            "date": "2023-08-17",
            "status": "successful",
            "title": "Length of Last Word",
            "text": "Дано рядок `s`, що складається зі слів і пробілів, повернути довжину останнього слова в рядку. Слово — це максимальний підрядок, що складається лише з символів, які не є пробілами. #cut \n### Обмеження: \n* 1 <= s.length <= 10^4^  \n* `s` складається лише з англійських літер і пробілів ' '.\n* У `s` буде принаймні одне слово. \n *** \n    Легка задача. Ідемо у циклі з кінця рядка. Пробіли пропускаємо, не пробіли рахуємо."
        },
        {
            "date": "2023-08-18",
            "status": "problem",
            "title": "Sqrt(x)",
            "text": "Дано невід’ємне ціле число `x`, поверніть квадратний корінь із `x`, округлений вниз до найближчого цілого числа. Повернене ціле число також має бути невід’ємним. Не можна використовувати будь-які вбудовані функції чи оператори експоненти. #cut \n### Обмеження: \n* 0 <= x <= 2^31^ - 1 \n *** \n Намагався зробити сам. Прочитав про розрахунок приблизного значення для початкового пошуку. Зробив з коррекцією у циклі за кроком 1. Подивився на Solutions. Виявилось, що треба використовувати бінарний пошук. Переробив свою реалізацію. Тепер там є приблизний розрахунок спочатку та бінарний пошук кореня. Поєднання цих підходів прискорює знаходження результату."
        },
        {
            "date": "2023-08-19",
            "status": "successful",
            "title": "Search Insert Position",
            "text": "Маючи відсортований масив різних цілих чисел і цільове значення, поверніть індекс, якщо ціль знайдено. Якщо ні, поверніть індекс там, де він був би, якби його вставили в порядку зростання. Ви повинні написати алгоритм зі складністю виконання `O(log n)`.\n#cut\n### Приклади: \n* **Input:** `nums = [1,3,5,6], target = 5` \n* **Output:** `2`\n* **Input:** `nums = [1,3,5,6], target = 2` \n* **Output:** `1` \n* **Input:** `nums = [1,3,5,6], target = 7` \n* **Output:** `4` \n### Обмеження:  \n* <code>1 <= nums.length <= 10<sup>4</sup></code> \n* <code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code> \n* **`nums` містить різні значення, відсортовані в порядку зростання.** \n* <code>-10<sup>4</sup> <= target <= 10<sup>4</sup></code> \n \n Написав функцію бінарного пошуку. Якщо target не знайдено, то повертається індекс куди його можна вставити щоб масив залишився відсортованим."
        },
        {
            "date": "2023-08-20",
            "status": "successful",
            "title": "Valid Sudoku",
            "text": "Визначте, чи дійсна дошка судоку `9 x 9`. Лише заповнені клітинки потрібно перевірити відповідно до таких правил: #cut \n* Кожен рядок має містити цифри `1-9` без повторень. \n* Кожна колонка повинна містити цифри `1-9` без повторень. \n* Кожен із дев’яти `3 х 3` підблоків сітки повинен містити цифри `1-9` без повторень.\n### Примітка \n* Дошка судоку (частково заповнена) може бути дійсною, але не обов’язково розв’язаною. \n* Тільки заповнені клітинки потрібно перевірити відповідно до згаданих правил.\n### Приклад 1:\n![Дошка судоку](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png) \n> **Input:** board = \n> [['5','3','.','.','7','.','.','.','.'] \n> ,['6','.','.','1','9','5','.','.','.'] \n> ,['.','9','8','.','.','.','.','6','.'] \n> ,['8','.','.','.','6','.','.','.','3'] \n> ,['4','.','.','8','.','3','.','.','1'] \n> ,['7','.','.','.','2','.','.','.','6'] \n> ,['.','6','.','.','.','.','2','8','.'] \n> ,['.','.','.','4','1','9','.','.','5'] \n> ,['.','.','.','.','8','.','.','7','9']] \n> **Output:** true \n\n### Приклад 2: \n\n> **Input:** board =  \n> [['8','3','.','.','7','.','.','.','.'] \n> ,['6','.','.','1','9','5','.','.','.'] \n> ,['.','9','8','.','.','.','.','6','.'] \n> ,['8','.','.','.','6','.','.','.','3'] \n> ,['4','.','.','8','.','3','.','.','1'] \n> ,['7','.','.','.','2','.','.','.','6'] \n> ,['.','6','.','.','.','.','2','8','.'] \n> ,['.','.','.','4','1','9','.','.','5'] \n> ,['.','.','.','.','8','.','.','7','9']] \n> **Output:** false \n> **Пояснення:** те саме, що в прикладі 1, за винятком того, що **5** у верхньому лівому куті змінено на **8**. Оскільки є дві 8-ки у верхньому лівому підблоку 3x3, він недійсний. \n\n### Обмеження: \n* `board.length == 9` \n* `board[i].length == 9` \n* `board[i][j]` є цифрою `1-9` або `'.'`. \n \nВирішив швидко цю задачу. Спочатку перевіряю кожний рядок. Для запам'ятовування цифр використовую set. Перед додаванням до сету завжди перевіряю, чи є поточна цифра у сеті. Якщо є, то повертаємо `false`. \nПотім, так само перевіряю кожний стовпець. \nДля перевірки підблоків написав функцію `checkSubBox(row, column)`, яка може перевіряти зазначений підблок `3 х 3`. \nЯкщо всі перевірки пройдені, повертаю `true`.\nА ось як виглядає код:\n```javascript\n/**\n * @param {character[][]} board\n * @return {boolean}\n */\nvar isValidSudoku = function(board) {\n\n    //Checks every row\n    for (let y = 0; y < 9; y++) {\n        const digitsOfRow = new Set();\n        for (let x = 0; x < 9; x++ ) {\n            const curr = board[y][x];\n            if (curr !== '.') {\n                if (digitsOfRow.has(curr)) {\n                    return false;\n                } else {\n                    digitsOfRow.add(curr);\n                }\n            }\n        }\n    }\n\n    //Checks every column\n    for (let x = 0; x < 9; x++) {\n        const digitsOfColumn = new Set();\n        for (let y = 0; y < 9; y++ ) {\n            const curr = board[y][x];\n            if (curr !== '.') {\n                if (digitsOfColumn.has(curr)) {\n                    return false;\n                } else {\n                    digitsOfColumn.add(curr);\n                }\n            }\n        }\n    }\n\n    //This function can check subBox that lay on row and column passed into args \n    const checkSubBox = function(row, column) {\n        const digitsOfSubBox = new Set();\n        for (let y = 0; y < 3; y++) {\n            for (let x = 0; x < 3; x++) {\n                const curr = board[(row * 3) + y][(column * 3) + x];\n                if (curr !== '.') {\n                    if (digitsOfSubBox.has(curr)) {\n                        return false;\n                    } else {\n                        digitsOfSubBox.add(curr);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    //Checks every subBox\n    for (let row = 0; row < 3; row++) {\n        for (let column = 0; column < 3; column++) {\n            if (checkSubBox(row, column) === false) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n};\n```"
        },
        {
            "date": "2023-08-21",
            "status": "successful",
            "title": "Check if Every Row and Column Contains All Numbers",
            "text": "Матриця `n x n` є **дійсною**, якщо кожен рядок і кожен стовпець містять **усі** цілі числа від `1` до `n` (**включно**). \nДано цілочисельну матрицю `n x n`, поверніть `true`, якщо матриця дійсна. В іншому випадку поверніть `false`. #cut \n### Приклад 1:\n![Image](https://assets.leetcode.com/uploads/2021/12/21/example1drawio.png)\n> **Input:** matrix = [[1,2,3],[3,1,2],[2,3,1]]\n> **Output:** true\n### Приклад 2:\n![Image](https://assets.leetcode.com/uploads/2021/12/21/example2drawio.png)\n> **Input:** [[1,1,1],[1,2,3],[1,2,3]]\n> **Output:** false\n\n### Обмеження\n* `n == matrix.length == matrix[i].length`\n* `1 <= n <= 100`\n* `1 <= matrix[i][j] <= n`\n \nЗадача легка. Перевіряю спочатку рядки, потім ствпчики. Перел кожним проходженням по рядку/стовпчику створюю set для запам'ятовування. Перевірка елемента відбувається таким шляхом: якщо у сеті такий елемент вже є, то повертаю false, а якщо немає, то додаю до сета. Якщо перевірка пройдена - повертаю true.\nА ось і код:\n \n```javascript\n/**\n * @param {number[][]} matrix\n * @return {boolean}\n */\nvar checkValid = function(matrix) {\n    const n = matrix.length;\n\n    //Checks every row\n    for (let y = 0; y < n; y++) {\n        const digitsOfRow = new Set();\n        for (let x = 0; x < n; x++ ) {\n            const curr = matrix[y][x];\n            if (digitsOfRow.has(curr)) {\n                return false;\n            } else {\n                digitsOfRow.add(curr);\n            }\n        }\n    }\n\n    //Checks every column\n    for (let x = 0; x < n; x++) {\n        const digitsOfColumn = new Set();\n        for (let y = 0; y < n; y++ ) {\n            const curr = matrix[y][x];\n            if (digitsOfColumn.has(curr)) {\n                return false;\n            } else {\n                digitsOfColumn.add(curr);\n            }\n        }\n    }\n    return true;\n}; \n```"
        },
        {
            "date": "2023-08-22",
            "status": "successful",
            "title": "Matrix Diagonal Sum",
            "text": "Дано квадратна матриця `mat`, поверніть суму діагоналей матриці.\n Включіть лише суму всіх елементів на головній діагоналі та всіх елементів на вторинній діагоналі, які не є частиною первинної діагоналі. #cut \n### Приклад 1:\n![Image](https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png) \n\n> **Input:** mat = [[1,2,3],\n>                   [4,5,6],\n>                   [7,8,9]]\n> **Output:** `25`\n> **Пояснення:** Сума діагоналей: 1 + 5 + 9 + 3 + 7 = 25\n> Зауважте, що mat[1][1] = 5 врахований тільки раз.\n\n### Приклад 2:\n> **Input:** mat = \n> [[1,1,1,1],\n>  [1,1,1,1],\n>  [1,1,1,1],\n>  [1,1,1,1]]\n> **Output:** 8\n### Приклад 3:\n> **Input:** mat = [[5]]\n> **Output:** 5\n\n### Обмеження:\n* `n == mat.length == mat[i].length`\n* `1 <= n <= 100`\n* `1 <= mat[i][j] <= 100`\n \nНічого складного. Проходимо по головній диагоналі, по вторинній - всі елементи додаємо до суми. Потім перевіряємо чи є непарною розмірність матриці, якщо є - то віднімаємо центровий елемент від суми. Повертаємо суму. Ось такаий код:\n```javascript\n/**\n * @param {number[][]} mat\n * @return {number}\n */\nvar diagonalSum = function(mat) {\n    let sum = 0;\n    const n = mat.length;\n\n    for (let i = 0; i < n; i++) {\n        sum = sum + mat[i][i];\n    }\n\n    for (let i = 0, j = n - 1; i < n; i++, j--) {\n        sum = sum + mat[i][j];\n    }\n\n    if ((n % 2) === 1) {\n        sum = sum - mat[(n - 1) / 2][(n - 1) / 2];\n    }\n\n    return sum;\n};\n```"
        },
        {
            "date": "2023-08-23",
            "status": "successful",
            "title": "Check if Matrix Is X-Matrix",
            "text": "Квадратна матриця називається **X-матрицею**, якщо виконуються **обидві** наступні умови:\n1. Усі елементи на діагоналях матриці **відмінні від нуля**. \n2. Усі інші елементи дорівнюють 0.  #cut  \nДано 2D цілочисельний масив `grid` розміром `n x n`, що представляє квадратну матрицю, поверніть `true`, якщо `grid` *є X-матрицею*. В іншому випадку поверніть `false`.\n### Приклад 1:\n![Image](https://assets.leetcode.com/uploads/2022/05/03/ex1.jpg) \n> **Input:** grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]\n> **Output:** true\n> **Explanation:** Зверніться до малюнку вище. \n> X-матриця повинна мати зелені елементи (діагоналі), відмінні від нуля, а червоні елементи – 0.\n> Таким чином, grid є X-матрицею.\n### Приклад 2:\n![Image](https://assets.leetcode.com/uploads/2022/05/03/ex2.jpg) \n> **Input:** grid = [[5,7,0],[0,3,1],[0,5,0]]\n> **Output:** false\n> **Explanation:** Зверніться до малюнку вище. \n> X-матриця повинна мати зелені елементи (діагоналі), відмінні від нуля, а червоні елементи – 0.\n> Таким чином, grid не є X-матрицею.\n### Constraints:\n* `n == grid.length == grid[i].length`\n* `3 <= n <= 100`\n* <code>0 <= grid[i][j] <= 10<sup>5</sup></code>\n \nЛегка задача. Проходимо послідовно по всіх елементах матриці. Перевіряємо кожний елемент. Якщо його індекси лежать на діагоналі, то елемент не має дорівнювати `0`. Але якщо індекси не на діагоналі, то елемент має дорівнювати `0`.\nОсь такий код:\n \n```javascript\n/**\n * @param {number[][]} grid\n * @return {boolean}\n */\nvar checkXMatrix = function(grid) {\n    const n = grid.length;\n\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            if (i === j || i === (n - j -1)) {\n                if (grid[i][j] === 0) {\n                    return false;\n                }\n            } else if (grid[i][j] !== 0) {\n                    return false;\n                }\n        }\n    }\n\n    return true;\n};\n```\n"
        },
        {
            "date": "2023-08-25",
            "status": "problem",
            "title": "Sudoku Solver",
            "text": "Напишіть програму для вирішення головоломки Судоку, заповнюючи порожні клітинки.\b                          Рішення судоку має відповідати **всім наступним правилам**:  #cut\n1. Кожна цифра `1-9` має зустрічатися рівно один раз у кожному рядку. \n2. Кожна з цифр `1-9` має зустрічатися рівно один раз у кожному стовпчику. \n3. Кожна з цифр `1-9` має зустрічатися рівно один раз у кожному з 9 підблоків `3x3` сітки. \n \n`'.'` символ позначає порожні клітинки.\n### Приклад 1:\n![Image](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)\n> **Ввід:** board = [['5','3','.','.','7','.','.','.','.'],['6','.','.','1','9','5','.','.','.'],['.','9','8','.','.','.','.','6','.'],['8','.','.','.','6','.','.','.','3'],['4','.','.','8','.','3','.','.','1'],['7','.','.','.','2','.','.','.','6'],['.','6','.','.','.','.','2','8','.'],['.','.','.','4','1','9','.','.','5'],['.','.','.','.','8','.','.','7','9']]\n> **Вивід:** [['5','3','4','6','7','8','9','1','2'],['6','7','2','1','9','5','3','4','8'],['1','9','8','3','4','2','5','6','7'],['8','5','9','7','6','1','4','2','3'],['4','2','6','8','5','3','7','9','1'],['7','1','3','9','2','4','8','5','6'],['9','6','1','5','3','7','2','8','4'],['2','8','7','4','1','9','6','3','5'],['3','4','5','2','8','6','1','7','9']]\n> **Пояснення:** Вхідна дошка показана вище, а єдине дійсне рішення показано нижче:\n> ![Image](https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png)\n\n### Обмеження:\n* `board.length == 9`\n* `board[i].length == 9`\n* `board[i][j]` є цифрою або `'.'`.\n* **Гарантовано**, що вхідна дошка має тільки одне рішення.\n \nНамагався написати своє рішення, але воно змогло вирішити лише перший тест-кейс. Щоб вирішувати більш складні ігри, там де треба вгадувати, без рекурсії не обійтися. Тому подився в solutions на топове рішення. Там пропонується використовувати пошук в глибину усіх рішень. Також що зробити хід, кожна цифра перевіряється валідатором (чи підходить вона).\nОсь такий код:\n\n```js\n/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\n\nfunction solveSudoku(board) {\n  const n = board.length;\n  dfs(board, n);\n}\n\nfunction dfs(board, n) {\n  // for every cell in the sudoku\n  for (let row = 0; row < n; row++) {\n    for (let col = 0; col < n; col++) {\n      // if its empty\n      if (board[row][col] !== '.') continue;\n      // try every number 1-9\n      for (let i = 1; i <= 9; i++) {\n        const c = i.toString();\n        // if that number is valid\n        if (isValid(board, row, col, n, c)) {\n          board[row][col] = c;\n          // continue search for that board, ret true if solution is reached\n          if (dfs(board, n)) return true;\n        }\n      }\n      // solution wasnt found for any num 1-9 here, must be a dead end...\n      // set the current cell back to empty\n      board[row][col] = '.';\n      // ret false to signal dead end \n      return false;\n    }\n  }\n  // all cells filled, must be a solution\n  return true;\n}\n\nfunction isValid(board, row, col, n, c) {\n  const blockRow = Math.floor(row / 3) * 3;\n  const blockCol = Math.floor(col / 3) * 3;\n  for (let i = 0; i < n; i++) {\n    if (board[row][i] === c || board[i][col] === c) return false;\n    const curRow = blockRow +  Math.floor(i / 3);\n    const curCol = blockCol +  Math.floor(i % 3);\n    if (board[curRow][curCol] === c) return false;\n  }\n  return true;\n}\n```"
        },
        {
            "date": "2023-08-26",
            "status": "problem",
            "title": "Best Time to Buy and Sell Stock",
            "text": "Вам надається масив `prices`, де `prices[i]` — це ціна даного запасу на i-й день.\n             Ви хочете максимізувати свій прибуток, вибравши **один день** для покупки одного запасу та вибравши **інший день у майбутньому** для продажу цього запасу. #cut Поверніть *максимальний прибуток, який ви можете отримати від цієї операції*. Якщо ви не можете отримати прибуток, поверніть `0`.\n\n### Приклад 1:\n> **Ввід:** prices = [7,1,5,3,6,4]\n> **Вивід:** 5\n> **Пояснення:** Купуйте в день 2 (ціна = 1) і продавайте в день 5 (ціна = 6), прибуток = 6-1 = 5.\n> Зауважте, що купувати в день 2 і продавати в день 1 заборонено, тому що ви повинні купити, перш ніж продати.\n\n### Приклад 2:\n> **Ввід:** prices = [7,6,4,3,1]\n> **Вивід:** 0\n> **Пояснення:** У цьому випадку транзакції не проводяться, а максимальний прибуток = 0.\n\n### Обмеження:\n* 1 <= prices.length <= 10^5^\n* 0 <= prices[i] <= 10^4^\n \nДовелося подивитись у solutions. Просте рішення яке в топі:\n1. Встаноивити два вказівника, left = 0 - для покупки, right = 1 - для продажу. \n2. Встановити max_profit = 0.\n3. У циклі, поки right менше ніж довжина масиву prices робити наступне:\n    1.  Якщо ціна на яку вказує left менша ціни right, то треба порахувати прибуток та порівняти з max-profit. Якщо прибуток буде більше то треба оновити max_prfit.\n    2. Інакше, то треба left прирівняти до right.\n    3. У будь-якому разі збільшуємо right на 1.\n4. Повертаємо max_profit.\n \nА ось код: \n\n```js\n/**\n * @param {number[]} prices\n * @return {number}\n */\nconst maxProfit = (prices) => {\n  let left = 0; // Buy\n  let right = 1; // Sell\n  let maxProfit = 0;\n  while (right < prices.length) {\n    if (prices[left] < prices[right]) {\n      let profit = prices[right] - prices[left]; // our current profit\n\n      maxProfit = Math.max(maxProfit, profit);\n    } else {\n      left = right;\n    }\n    right++;\n  }\n  return maxProfit;\n};\n```"
        },
        {
            "date": "2023-08-27",
            "status": "fail",
            "title": "Median of Two Sorted Arrays",
            "text": "Дано два відсортованих масиви `nums1` і `nums2` розміру `m` і `n` відповідно, поверніть **медіану** двох відсортованих масивів.\n            Загальна складність часу виконання має становити `O(log (m+n))`. #cut \n### Приклад 1:\n\n> **Ввід:** nums1 = [1,3], nums2 = [2]\n> **Вивід:** 2.00000\n> **Пояснення:** об'єднаний масив = [1,2,3] та медіана 2.\n\n### Приклад 2:\n\n> **Ввід:** nums1 = [1,2], nums2 = [3,4]\n> **Вивід:** 2.50000\n> **Пояснення:** об'єднаний масив = [1,2,3,4] та медіана is (2 + 3) / 2 = 2.5.\n\n### Обмеження:\n* nums1.length == m\n* nums2.length == n\n* 0 <= m <= 1000\n* 0 <= n <= 1000\n* 1 <= m + n <= 2000\n* -10^6^ <= nums1[i], nums2[i] <= 10^6^\n \nТут взагалі було не зрозуміло, як вирішувати цю задачу рівня hard. В editorial пишуть, що треба використовувати покращений бінарний пошук, щоб досягти потрібної ефективності.\n\n\n```js\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\n\nvar findMedianSortedArrays = function(nums1, nums2) {\n    let n1 = nums1.length;\n    let n2 = nums2.length;\n    \n    // If nums1 is larger than nums2, swap them to ensure n1 is smaller than n2.\n    if (n1 > n2) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    let l = 0;\n    let r = n1;\n    while (l <= r) {\n        let mid1 = Math.floor((l + r) / 2);\n        let mid2 = Math.floor((n1 + n2 + 1) / 2 - mid1);\n        \n        let maxLeft1 = (mid1 == 0) ? Number.MIN_SAFE_INTEGER : nums1[mid1-1];\n        let minRight1 = (mid1 == n1) ? Number.MAX_SAFE_INTEGER : nums1[mid1];\n        \n        let maxLeft2 = (mid2 == 0) ? Number.MIN_SAFE_INTEGER : nums2[mid2-1];\n        let minRight2 = (mid2 == n2) ? Number.MAX_SAFE_INTEGER : nums2[mid2];\n        \n        if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\n            if ((n1 + n2) % 2 == 0) {\n                return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2;\n            } else {\n                return Math.max(maxLeft1, maxLeft2);\n            }\n        } else if (maxLeft1 > minRight2) {\n            r = mid1 - 1;\n        } else {\n            l = mid1 + 1;\n        }\n    }\n    \n    return -1;\n};\n```"
        },
        {
            "date": "2023-08-28",
            "status": "fail",
            "title": "Search in Rotated Sorted Array",
            "text": "Є цілочисельний масив `nums`, відсортований у порядку зростання (з **різними** значеннями).\n            Перш ніж передати у вашу функцію, `nums`, **можливо обертався** до невідомого індекса опорної точки `k` (`1 <= k < nums.length`), щоб у результаті вийшов масив `[nums[k], nums[k+1], ... , nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**з індексом 0**). Наприклад, `[0,1,2,4,5,6,7]` можна обернути до індексу опори `3` і стати `[4,5,6,7,0,1,2]`. #cut Даний масив `nums` **після** можливого обертання та ціле число `target`, повернути індекс `target`, якщо він є у `nums`, або `-1`, якщо він не є у `nums`.\nВи повинні написати алгоритм зі складністю виконання `O(log n)`.\n\n### Приклад 1:\n\n> **Input:** nums = [4,5,6,7,0,1,2], target = 0\n> **Output:** 4\n\n### Приклад 2:\n\n> **Input:** nums = [4,5,6,7,0,1,2], target = 3\n> **Output:** -1\n\n### Приклад 3:\n\n> **Input:** nums = [1], target = 0\n> **Output:** -1\n\n### Обмеження:\n* 1 <= nums.length <= 5000\n* -10^4^ <= nums[i] <= 10^4^\n* Усі значення `nums` **унікальні**.\n* nums — це зростаючий масив, який, можливо, обертався.\n* -10^4^ <= target <= 10^4^\n \nНе зміг самостійно написати щось робоче. Розглянув editorial. Задача про бінарний пошук. Але можливе обертання додає складності. Пропонують розділити задачу на дві під-задачі: \n1. Знайти індекс опорного елементу (для цього теж використовується бінарний пошук).\n2. Виконати пошук у двох підмасивах (межа між ними це і є той індекс).\n \nКод, який це робить наведений нижче.\nТакож можна застосувати підхід, де бінарний пошук робиться тільки один раз по всьому масиву без попереднього пошуку k-індекса. Там порівнюються межі кожного пів-масиву з ціллю, щоб обирати правильну половину.\n```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nconst search = function(nums, target) {\n    const n = nums.length;\n    let left = 0, right = n - 1;\n\n    // Find the index of the pivot element (the smallest element)\n    while (left <= right) {\n        const mid = left + ~~((right - left) / 2);\n        if (nums[mid] > nums[n - 1]) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    // Binary search over elements on the pivot element's left\n    const answer = binarySearch(nums, 0, left - 1, target);\n    if (answer !== -1) {\n        return answer;\n    }\n\n    // Binary search over elements on the pivot element's right\n    return binarySearch(nums, left, n - 1, target);\n};\n\n// Binary search over an inclusive range [left_boundary ~ right_boundary]\nconst binarySearch = function(nums, leftBoundary, rightBoundary, target) {\n    let left = leftBoundary, right = rightBoundary;\n    while (left <= right) {\n        const mid = left + ~~((right - left) / 2);\n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return -1;\n}\n\n```\n\n\n"
        },
        {
            "date": "2023-08-30",
            "status": "successful",
            "title": "Valid Palindrome",
            "text": "Фраза є **паліндромом**, якщо після перетворення всіх великих літер на малі та видалення всіх неалфавітно-цифрових символів вона читається однаково вперед і назад. Алфавітно-цифрові символи включають літери та цифри.\n            Дано рядок `s`, поверніть `true`, *якщо це є **паліндромом**, або* `false` *у іншому випадку*. #cut \n### Приклад 1:\n> **Ввід:** s = 'A man, a plan, a canal: Panama'\n> **Вивід:** true\n> **Пояснення:** 'amanaplanacanalpanama' є паліндромом.\n\n### Приклад 2:\n> **Ввід:** s = 'race a car'\n> **Вивід:** false\n> **Пояснення:** 'raceacar' не є паліндромом.\n\n### Приклад 3:\n> **Ввід:** s = ' '\n> **Вивід:** true\n> **Пояснення:** s - це порожній рядок '' після видалення символів, які не є алфавітно-цифровими. Оскільки порожній рядок читається однаково вперед і назад, це паліндром.\n\n### Обмеження:\n* 1 <= s.length <= 2 * 10^5^\n* `s` складається лише з друкованих символів ASCII.\n \nНаписав своє рішення. Спочатку формую строку у нижньому регистрі та за один прохід видаляю пробіли. Потім, другим проходом порівнюю початок та кінець рядка, доки не дійду середини. Але мені більше подобається інше рішення, де задача розв'язується за один прохід. Ось код:\n\n```JavaScript\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isPalindrome = function(s){\n    let left = 0, right = s.length - 1;\n    while (left < right) {\n        if (!isAlphaNumeric(s[left]))\n            left++;\n        else if (!isAlphaNumeric(s[right]))\n            right--;\n        else if (s[left].toLowerCase() !== s[right].toLowerCase())\n            return false;\n        else {\n            left++;\n            right--;\n        }\n    }\n    return true;\n}\n\nfunction isAlphaNumeric(char) {\n    const code = char.charCodeAt(0);\n    return (code >= 48 && code <= 57) || (code >= 65 && code <= 90) || (code >= 97 && code <= 122);\n}\n```"
        },
        {
            "date": "2023-08-31",
            "status": "successful",
            "title": "Valid Anagram",
            "text": "Дано два рядки `s` і `t`, поверніть 'true', *якщо* `t` *є анаграмою* `s`, *і* `false` *в іншому випадку*. #cut **Анаграма** — це слово або фраза, утворена шляхом перестановки літер іншого слова чи фрази, зазвичай з використанням усіх вихідних букв рівно один раз.\n\n### Приклад 1:\n\n> **Ввід:** s = 'anagram', t = 'nagaram'\n> **Вивід:** true\n\n### Приклад 2:\n\n> **Ввід:** s = 'rat', t = 'car'\n> **Вивід:** false\n\n### Обмеження:\n* 1 <= s.length, t.length <= 5 * 10^4^\n* `s` і `t` складаються з малих літер англійської мови.\n \nМоє рішення було таким що: \n* Спочатку порівнюю довжини рядків, якщо вони різні, повертаю false\n* Потім створюю два масиви з похідних рядків\n* Обидва масиви сортую, обидва зклеюю у рядки та порівнюю, результат порівняя повертаю\n \nАле більш оптимальним є інше рішення, де підраховується частота включень символів у рядку. Код такого рішення наведено нижчке:\n\n```JavaScript\n/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isAnagram = function(s, t) {\n    if (s.length !== t.length) {\n        return false;\n    }\n    \n    var freq = new Array(26).fill(0);\n    for (var i = 0; i < s.length; i++) {\n        freq[s.charCodeAt(i) - 'a'.charCodeAt(0)]++;\n        freq[t.charCodeAt(i) - 'a'.charCodeAt(0)]--;\n    }\n    \n    for (var i = 0; i < freq.length; i++) {\n        if (freq[i] !== 0) {\n            return false;\n        }\n    }\n    \n    return true;\n};\n```\n"
        },
        {
            "date": "2023-09-01",
            "status": "successful",
            "title": "Contains Duplicate",
            "text": "Дано цілочисельний масив `nums`, поверніть `true`, якщо будь-яке значення з’являється в масиві принаймні двічі, і поверть `false`, якщо кожен елемент є відмінним. #cut \n### Приклад 1:\n\n> **Ввід:** nums = [1,2,3,1]\n> **Вивід:** true\n\n### Приклад 2:\n\n> **Ввід:** nums = [1,2,3,4]\n> **Вивід:** false\n\n### Приклад 3:\n\n> **Ввід:** nums = [1,1,1,3,3,4,3,2,4,2]\n> **Вивід:** true\n\n### Обмеження:\n* 1 <= nums.length <= 10^5^\n* -10^9^ <= nums[i] <= 10^9^\n \nНайпростіше рішення полягає в тому, що створюється Set і його розмір порівнюється довжиною `nums`. Ось код:\n\n```JavaScript\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar containsDuplicate = function(nums) {\n    return ((new Set(nums)).size !== nums.length);\n};\n```"
        },
        {
            "date": "2023-09-02",
            "status": "successful",
            "title": "Remove Duplicates from Sorted List",
            "text": "Дано `head` відсортованого пов’язаного списку, *видаліть усі дублікати, щоб кожен елемент з’являвся лише один раз*. Поверніть *зв’язаний список також **відсортованим***. #cut \n### Приклад 1:\n\n![Image](https://assets.leetcode.com/uploads/2021/01/04/list1.jpg)\n> **Ввід:** head = [1,1,2]\n> **Вивід:** [1,2]\n\n### Приклад 2:\n\n![Image](https://assets.leetcode.com/uploads/2021/01/04/list2.jpg)\n> **Ввід:** head = [1,1,2,3,3]\n> **Вивід:** [1,2,3]\n\n### Обмеження:\n* Кількість вузлів у списку знаходиться в діапазоні `[0, 300]`.\n* -100 <= Node.val <= 100\n* Список гарантовано буде **відсортований** у порядку зростання.\n \nРішення досить просте. Проходжу по списку та порівнюю значення елементу поточного та попереднього. Якщо вони однакові, то поточний елемент видаляється із списку. Видалення здійснюється через присвоєння полю next слідуючого елементу. \nКод рішення наведено нижче:  \n \n```JavaScript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar deleteDuplicates = function(head) {\n    if (head === null) return head;\n    let current = head.next;\n    let prev = head;\n    while (current !== null) {\n        if (current.val === prev.val) {\n            prev.next = current.next;\n        } else {\n          prev = current;  \n        }\n        current = current.next;\n    }\n    return head;\n};\n```"
        },
        {
            "date": "2023-09-03",
            "status": "successful",
            "title": "Power of Two",
            "text": "Дано ціле число `n`, поверніть *`true`, якщо воно є степенем двійки. В іншому випадку поверніть `false`*.\n Ціле число `n` є ступенем двійки, якщо існує таке ціле число `x`, що <code>n == 2<sup>x</sup></code>. #cut \n### Приклад 1:\n\n> **Ввід:** n = 1\n> **Вивід:** true\n> **Пояснення:** 2^0^ = 1\n\n### Приклад 2:\n\n> **Ввід:** n = 16\n> **Вивід:** true\n> **Пояснення:**: 2^4^ = 16\n\n### Приклад 3:\n\n> **Ввід:** n = 3\n> **Вивід:** false\n\n### Обмеження:\n* -2^31^ <= n <= 2^31^ - 1\n \n**Додаткові дії:** чи могли б ви вирішити це без циклів/рекурсії?\n\nЯкщо вирішувати за допомогою циклів, то пропоную такий варіант:\n* якщо `n < 1`, повертаємо `false`\n* якщо `n === 1`,  повертаємо `true` \n* якщо `n > 1`, конвертуємо число `n` у рядок у бінарному вигляді\n* далі, проходимо по рядку і дивимось, щоб не було `1` окрім першого символу\n* якщо десь зустрінеться `1` повертаємо `false`, інакше - `true`.\n Ось код рішення:\n \n```JavaScript\n/**\n * @param {number} n\n * @return {boolean}\n */\nvar isPowerOfTwo = function(n) {\n  if (n > 1) {\n      const str = n.toString(2);\n      for (let i = 1; i < str.length; i++) {\n         if (str[i] === '1') return false;\n      }\n      return true;\n   } else if (n === 1) return true;\n   else if (n < 1 ) return false;\n};\n```\n\nАле якщо треба без циклів, пропоную використати зведення у ступінь: \n```JavaScript\n        if (n > 1) {\n               return (2 ** (n.toString(2).length - 1) === n);\n         } else if (n === 1) return true; \n        else if (n < 1) return false;\n```"
        },
        {
            "date": "2023-09-04",
            "status": "successful",
            "title": "Can Place Flowers",
            "text": "У вас є довга клумба, на якій частина ділянок засаджена, а частина ні. Однак на **суміжних** ділянках квіти садити не можна.            Дано масив цілих чисел `flowerbed`, що містить `0` і `1`, де `0` означає порожню ділянку, а `1` означає не порожню ділянку, і ціле число `n`, поверніть `true`, *якщо `n` нових квітів можна висадити на клумбі без порушення правила заборони сусідніх квітів, і `false` в іншому випадку*. #cut \n### Приклад 1:\n\n> **Ввід:** flowerbed = [1,0,0,0,1], n = 1\n> **Вивід:** true\n\n### Приклад 2:\n\n> **Ввід:** flowerbed = [1,0,0,0,1], n = 2\n> **Вивід:** false\n\n\n### Обмеження:\n* 1 <= flowerbed.length <= 2 * 10^4^\n* flowerbed[i] є 0 або 1.\n* На `flowerbed` немає двох сусідніх квітів.\n* 0 <= n <= flowerbed.length\n \nРішення полягає у тому, що треба пройти по масиву і підрахувати кількість місць, куди можна висадити квіти. Потім цю кількість порівнюємо з `n` і повертаємо відповідний результат. \nКод рішення наведений нижче:\n \n```JavaScript\n/**\n * @param {number[]} flowerbed\n * @param {number} n\n * @return {boolean}\n */\nvar canPlaceFlowers = function(flowerbed, n) {\n    let i = 0, len = flowerbed.length;\n    let count = 0;\n    while (i < len) {\n        if ((flowerbed[i] === 0) && \n        (flowerbed[i - 1] === 0 || flowerbed[i - 1] === undefined) && \n        ((flowerbed[i + 1] === 0 || flowerbed[i + 1] === undefined))) {\n            count++;   \n            i++;             \n        }\n        if (flowerbed[i] === 1) i++;\n        i++;\n    }\n    return count >= n;\n};\n```\n"
        },
        {
            "date": "2023-09-05",
            "status": "successful",
            "title": "Ransom Note",
            "text": "Дано два рядки `ransomNote` і `magazine`, повертніть `true`, *якщо `ransomNote` можна створити за допомогою літер із `magazine`, і `false` в іншому випадку*. #cut Кожну літеру з `magazine` можна використати лише один раз у `ransomNote`.\n\n### Приклад 1:\n\n> **Ввід:** ransomNote = \"a\", magazine = \"b\"\n> **Вивід:** false\n\n### Приклад 2:\n\n> **Ввід:** ransomNote = \"aa\", magazine = \"ab\"\n> **Вивід:** false\n\n### Приклад 3:\n\n> **Ввід:** ransomNote = \"aa\", magazine = \"aab\"\n> **Вивід:** true\n\n### Обмеження:\n* 1 <= ransomNote.length, magazine.length <= 10^5^\n* `ransomNote` та `magazine` складаються з малих літер англійської мови.\n \nМоє рішення просте: Підрахувати кількіть кожної літери в `ransomNote`, потім підраховати кількість відповідних літер у `magazine` та порівняти ці кількості відповідно. Якщо літер з `magazine` вистачає повертаємо `true`. Інакше - `false`.\nКод рішення наведено нижче:\n  \n```js\n/**\n * @param {string} ransomNote\n * @param {string} magazine\n * @return {boolean}\n */\nvar canConstruct = function(ransomNote, magazine) {\n    \n    const c = 'a'.charCodeAt(0);\n    var freq = new Array(26).fill(0);\n    \n    for (var i = 0; i < ransomNote.length; i++) {\n        freq[ransomNote.charCodeAt(i) - c]++;\n    }\n\n    for (var i = 0; i < magazine.length; i++) {\n        if (freq[magazine.charCodeAt(i) - c] > 0) {\n            freq[magazine.charCodeAt(i) - c]--;\n        }\n    }\n    \n    for (var i = 0; i < freq.length; i++) {\n        if (freq[i] !== 0) {\n            return false;\n        }\n    }\n    \n    return true;\n};\n```\n"
        },
        {
            "date": "2023-09-06",
            "status": "successful",
            "title": "Diameter of Binary Tree",
            "text": "Дано `root` бінарного дерева, поверніть *довжину **діаметра** дерева*. #cut **Діаметр** бінарного дерева - це **довжина** найдовшого шляху між будь-якими двома вузлами в дереві. Цей шлях може проходити або не проходити через `root`.\n**Довжина** шляху між двома вузлами представлена ​​кількістю ребер між ними.\n\n### Приклад 1:\n\n![Image](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)\n> **Ввід:** root = [1,2,3,4,5]\n> **Вивід:** 3\n> **Пояснення:** 3 є довжиною шляху [4,2,1,3] або [5,2,1,3].\n\n### Приклад 2:\n\n> **Ввід:** root = [1,2]\n> **Вивід:** 1\n\n### Обмеження:\n* Кількість вузлів у дереві знаходиться в діапазоні [1, 10^4^].\n* -100 <= Node.val <= 100\n \nРішення таке: Виконую рекурсивний обхід дерева за алгоритмом DFS та одразу шукаю найбільший діаметр. Поточний діаметр це сума найбільшої глибмни правого та лівого піддерев. Максимальний діаметр збереігається у окремій змінній та перевіряється на кожному кроці.\nКод рішення наведений нижче:\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\n\n\nvar diameterOfBinaryTree = function(root) {\n    let maxDiameter = 0;\n\n    function dfs(root) {\n        if (root === null) {\n            return 0;\n        }\n\n        let l = 0, r = 0.\n\n        if (root.left !== null) {\n            l = dfs(root.left)\n        } \n        if (root.right !== null) {\n            r = dfs(root.right);\n        }\n    \n        maxDiameter = Math.max(l + r, maxDiameter);   \n        \n        return 1 + Math.max(l, r);\n    };\n\n    dfs(root);\n    return maxDiameter;\n};\n```\n"
        },
        {
            "date": "2023-09-07",
            "status": "successful",
            "title": "Middle of the Linked List",
            "text": "Дано `head` однозв’язаного списку, поверніть *середній вузол зв’язаного списку*.\nЯкщо середніх вузлів два, поверніть **другий середній** вузол. \n#cut\n### Приклад 1:\n![Image](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg)\n> **Ввід:** head = [1,2,3,4,5]\n> **Вивід:** [3,4,5]\n> **Пояснення:** Середнім вузлом списку є вузол 3.\n\n### Приклад 2:\n![Image](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg)\n> **Ввід:** head = [1,2,3,4,5,6]\n> **Вивід:** [4,5,6]\n> **Пояснення:** Оскільки список має два середніх вузла зі значеннями 3 і 4, ми повертаємо другий.\n\n### Обмеження:\n* Кількість вузлів у списку знаходиться в діапазоні `[1, 100]`.\n* `1 <= Node.val <= 100`\n \nМоє рішення таке. Проходимо по списку до кінця за допомогою двох вказівників. Але один з них пересувається у двічі частіше, і коли він досягне кінця списку, то другий вказівник буде вказувати на середній або другий середній елемент. \nКод рішення наведено нижче:\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n    let current = head.next;\n    let mid = head;\n    while (current !== null) {\n        mid = mid.next;\n        current = current.next;\n        if (current !== null) {\n            current = current.next;\n        }\n    }\n    return mid;\n};\n```"
        },
        {
            "date": "2023-09-08",
            "status": "successful",
            "title": "Climbing Stairs",
            "text": "Ви піднімаєтеся по сходах. Щоб досягти вершини, потрібно зробити `n` кроків.\nКожен раз ви можете піднятися на `1` або `2` сходинки. Скількома способами можна піднятися на вершину?\n#cut\n### Приклад 1:\n> **Ввід:** n = 2\n> **Вивід:** 2\n> **Пояснення:** Піднятися на вершину можна двома способами.\n> 1. 1 step + 1 step\n> 2. 2 steps\n\n### Приклад 2:\n> **Ввід:** n = 3\n> **Вивід:** 3\n> **Пояснення:** Піднятися на вершину можна трьома способами.\n> 1. 1 step + 1 step + 1 step\n> 2. 1 step + 2 steps\n> 3. 2 steps + 1 step\n\n### Обмеження:\n* `1 <= n <= 45`\n \nСпочатку вирішив це завдвння за допомогою рекурсії. Але такий підхід дуже довго обчислюється якщо `n` більше 30. Придивившись к послідовності чисел на виході, при тест-кейсах від 1 до 8, було помічено що це числа Фібоначі. А їх дуже легко можна обчислити у циклі.\nКод рішення наведено нижче:\n```js\n/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isSubsequence = function(s, t) {\n    const sl = s.length, tl = t.length; \n    if (sl === 0) return true;\n    for(let i = 0, j = 0; i < tl; i++) {\n        if (t[i] === s[j]) {\n            j++;\n            if (j === sl) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n```"
        },
        {
            "date": "2023-09-09",
            "status": "successful",
            "title": "Maximum Depth of Binary Tree",
            "text": "Дано `root` бінарного дерева, поверніть *його максимальну глибину*.\n**Максимальна глибина** бінарного дерева — це кількість вузлів уздовж найдовшого шляху від кореневого вузла до найдальшого кінцевого вузла.\n#cut\n### Приклад 1:\n![Image](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)\n> **Ввід:** root = [3,9,20,null,null,15,7]\n> **Вивід:** 3\n\n### Приклад 2:\n> **Ввід:** root = [1,null,2]\n> **Вивід:** 2\n\n### Обмеження:\n* Кількість вузлів у дереві знаходиться в діапазоні [1, 10^4^].\n* -100 <= Node.val <= 100\n \nВикоритовую алгоритм обходу DFS. Рекурсивно викликається функція dfs на кожному вузлі. Ця функція порівнює ліве та праве піддререва за глубиною, та повертає максимальне з них, додаючи одиницю.\nКод рішення наведено нижче: \n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    \n    function dfs(root) {\n        if (root === null) {\n            return 0;\n        }\n\n        let l = 0, r = 0.\n\n        if (root.left !== null) {\n            l = dfs(root.left)\n        } \n        if (root.right !== null) {\n            r = dfs(root.right);\n        }\n       \n        return 1 + Math.max(l, r);\n    };\n\n    return dfs(root);\n};\n```\n"
        },
        {
            "date": "2023-09-10",
            "status": "successful",
            "title": "Same Tree",
            "text": "Дано корені двох бінарних дерев `p` і `q`, напишіть функцію, щоб перевірити, чи вони однакові.\nДва бінарних дерева вважаються однаковими, якщо вони структурно ідентичні, а вузли мають однакове значення.\n#cut\n### Приклад 1:\n![Image](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)\n> **Ввід:** p = [1,2,3], q = [1,2,3]\n> **Вивід:** true\n\n### Приклад 2:\n![Image](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)\n> **Ввід:** p = [1,2], q = [1,null,2]\n> **Вивід:** false\n\n### Приклад 3:\n![Image](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)\n> **Ввід:** p = [1,2,1], q = [1,1,2]\n> **Вивід:** false\n\n### Обмеження:\n* Кількість вузлів у дереві знаходиться в діапазоні [1, 10^4^].\n* -100 <= Node.val <= 100\n \nДля рішення цієї задачі застосовую метод обходу DFS. Написав функцію `dfs(p, q)` яка працює на двох деревах рекурсивно. Вона повертає `true` якщо дерева однакові, та `false` у іншому випадку. На кожному кроці порівнюються лівий та правий потомок, а також значення вузла. Якщо хоч десь буде відмінність, то `false` \"вспливе\" та стане результатом.  \nКод рішення наведено нижче:\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    \n    function dfs(p, q) {\n        if (p === null && q === null) {\n            return true;\n        } else if (p === null || q === null) {\n            return false;\n        }\n\n        if (p.val !== q.val) {\n            return false;\n        }\n        \n        if ((p.left !== null && q.left === null) || (p.left === null && q.left !== null) || \n        (p.right !== null && q.right === null) || (p.right === null && q.right !== null)) {\n            return false;\n        }\n\n        if (p.left !== null && p.right === null)  {\n            return dfs(p.left, q.left)\n        } \n        if (p.right !== null && p.left === null) {\n            return dfs(p.right, q.right);\n        }\n        \n        return dfs(p.left, q.left) && dfs(p.right, q.right);\n    };\n\n    return dfs(p, q);\n};\n```\n"
        },
        {
            "date": "2023-09-11",
            "status": "successful",
            "title": "Symmetric Tree",
            "text": "Дано `root` бінарного дерева, *перевірте, чи є він дзеркалом самого себе* (тобто симетричним відносно свого центру).\n#cut\n### Приклад 1:\n![Image](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)\n> **Ввід:** root = [1,2,2,3,4,4,3]\n> **Вивід:** true\n\n### Приклад 2:\n![Image](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)\n> **Ввід:** root = [1,2,2,null,3,null,3]\n> **Вивід:** false\n\n### Обмеження:\n* Кількість вузлів у дереві знаходиться в діапазоні `[1, 1000]`.\n* `-100 <= Node.val <= 100`\n \nДуже схожа задача на **Same Tree**, от тільки тепер треба порівнювати ліве піддерево та праве піддерево вузла `root`. Отже рекурсивно обходимо методом DFS одразу два піддререва, але рухаємось у другому піддереві \"дзеркально\" до першого. Також \"дзеркально\" порівнюємо нащадків, щоб визначити відмінність. Функція dfs поверне false, якщо десь у піддеревах виявиться відмінність від симетрії.\nКод рішення наведено нижче:\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isSymmetric = function(root) {\n    function dfs(p, q) {\n        if (p === null && q === null) {\n            return true;\n        } else if (p === null || q === null) {\n            return false;\n        }\n\n        if (p.val !== q.val) {\n            return false;\n        }\n        \n        if ((p.left !== null && q.right === null) || (p.left === null && q.right !== null) || \n        (p.right !== null && q.left === null) || (p.right === null && q.left !== null)) {\n            return false;\n        }\n\n        if (p.left !== null && p.right === null)  {\n            return dfs(p.left, q.right)\n        } \n        if (p.right !== null && p.left === null) {\n            return dfs(p.right, q.left);\n        }\n        \n        return dfs(p.left, q.right) && dfs(p.right, q.left);\n    };\n\n    if (root === null) {\n        return true;\n    }\n    return dfs(root.left, root.right);\n};\n```"
        },
        {
            "date": "2023-09-12",
            "status": "successful",
            "title": "Is Subsequence",
            "text": "Дано два рядки `s` і `t`, поверніть `true`, *якщо `s` є **підпослідовністю** `t`, або `false` в іншому випадку*. \n#cut\n**Підпослідовність** рядка — це новий рядок, який формується з вихідного рядка шляхом видалення деяких символів (може бути жодного) без порушення відносних позицій символів, що залишилися. (тобто `\"ace\"` є підпослідовністю |{|\"_a_&shy;b&shy;_c_&shy;d&shy;_e_\"|}|, а `\"aec\"` — ні).\n\n### Приклад 1:\n> **Ввід:**     s = \"abc\", t = \"ahbgdc\"\n> **Вивід:** true\n### Приклад 2:\n> **Ввід:**   s   = \"axc\", t = \"ahbgdc\"\n> **Вивід:** false\n\n### Обмеження:\n* `0 <= s.length <= 100`\n* |{| 0 <= t.length <= 10^4^|}|\n* `s` і `t` складається тільки з англійських літер у нижньому регистрі.\n \n**Подальші дії**: припустимо, що є багато вхідних `s`, скажімо, |{|s~1~, s~2~, ..., s~k~|}|, де |{|k >= 10^9^|}|, і ви хочете перевірити один за одним, щоб побачити, чи `t` має свою підпослідовність. У цьому випадку, як би ви змінили свій код?\n  \nМоє рішення наступне:\n- спочатку аналізую довжини вхідних рядків - якщо довжина `s` більша за `t`, то повертаю `false`, а якщо довжина `s == 0`, то повертаю `true`;\n- далі виконую прохід по рядку `t` спочатку та перевіряю на рівність з першою літерою рядка `s`;\n- якщо літери співпадають беру для перевірки наступну літеру з `s` та продовжую йти по `t`;\n- якщо всі літери з `s` буде знайдено, повертаю  `true`, інакше - `false`.\n \nКод рішення наведено нижче:\n\n```js\n/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isSubsequence = function(s, t) {\n    const sl = s.length, tl = t.length; \n    if (sl === 0) return true;\n    if (sl > tl) return false;\n    for(let i = 0, j = 0; i < tl; i++) {\n        if (t[i] === s[j]) {\n            j++;\n            if (j === sl) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n```"
        },
        {
            "date": "2023-09-13",
            "status": "successful",
            "title": "Pascal's Triangle",
            "text": "Дано ціле число `numRows`, повернути перші numRows **трикутника Паскаля**.\nУ **трикутнику Паскаля** кожне число є сумою двох чисел безпосередньо над ним, як показано:\n#cut\n![Pascal's triangle](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\n\n### Приклад 1:\n> **Ввід:**  numRows = 5\n> **Вивід:** [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n\n### Приклад 2:\n> **Ввід:** numRows = 1\n> **Вивід:** [[1]]\n\n### Обмеження:\n* `1 <= numRows <= 30`\n \nМоє рішення - використання комбінаторної формули: вставляти в результуючий масив кожного разу новий рядок, який розрахований на основі попереднього. \nКод рішення наведено нижче:\n```js\n/**\n * @param {number} numRows\n * @return {number[][]}\n */\nvar generate = function(numRows) {\n    let result = [];\n    for (let i = 0; i < numRows; i++ ) {\n        switch (i) {\n            case 0: result.push([1]);\n                break;\n            case 1: result.push([1,1]);\n                break;\n            default: {\n                let row = [1];\n                for (let j = 1; j < i; j++) {\n                    row.push( result[i - 1][j - 1] + result[i - 1][j]);\n                }\n                row.push(1);\n                result.push(row);\n            }\n        }\n    }\n    return result;\n};\n```"
        },
        {
            "date": "2023-09-14",
            "status": "successful",
            "title": "Pascal's Triangle II",
            "text": "Дано задано ціле число `rowIndex`, поверніть |{|rowIndex^th^|}| (**з 0-індексом**) рядок **трикутника Паскаля**.\n#cut\nУ **трикутнику Паскаля** кожне число є сумою двох чисел безпосередньо над ним, як показано:\n\n![Pascal's triangle](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\n\n### Приклад 1:\n> **Ввід:**  rowIndex = 3\n> **Вивід:** [1,3,3,1]\n\n### Приклад 2:\n> **Ввід:** rowIndex = 0\n> **Вивід:** [1]\n\n### Приклад 3:\n> **Ввід:** rowIndex = 1\n> **Вивід:** [1,1]\n\n### Обмеження:\n* `0 <= rowIndex <= 33`\n \n**Додаткові дії**: чи можете ви оптимізувати свій алгоритм, щоб використовувати лише `O(rowIndex)` додаткового місця?\n\nМожна використати той самий код рішення, що був в проблемі **Pascal's Triangle**, але замінити повернення результуючого масива поверненням останнього рядка. \nЯкщо треба обмежити використання додаткової пам'яті, то можна зберігати тільки поточний та попередній рядки. Але це все неоптимальні підходи. \nЄ рішення де одразу можна за лінійний час обчислити потрібний ряд у трикутнику Паскаля. Але з ним треба бути обережним обчислюється добуток коефіцієнтів та може статися переповнення. \nКод такого рішення наведено нижче:\n```js\n/**\n * @param {number} rowIndex\n * @return {number[]}\n */\nvar getRow = function(r) {\n    var ans = new Array(r+1);\n    ans[0] = ans[r] = 1;\n    for (i = 1, up = r; i < r; i++ ,up--)\n        ans[i] = ans[i - 1] * up / i;\n    return ans;\n};\n```"
        },
        {
            "date": "2023-09-15",
            "status": "successful",
            "title": "Path Sum",
            "text": "Дано `root` бінарного дерева та ціле число `targetSum`, поверніть `true`, якщо дерево має шлях **від кореня до листя**, так що додавання всіх значень уздовж шляху дорівнює `targetSum`.\n**Листок** — це вузол без дітей.\n#cut\n### Приклад 1:\n![Binary tree](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)\n> **Ввід:** root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n> **Вивід:** true\n> **Пояснення:** Показано шлях від кореня до листа з цільовою сумою.\n\n### Приклад 2:\n![Small binary tree](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)\n> **Ввід:** root = [1,2,3], targetSum = 5\n> **Вивід:** false\n> **Пояснення:** У дереві є два шляхи від кореня до листа:\n> (1 --> 2): Сума дорівнює 3.\n> (1 --> 3): Сума дорівнює 4.\n> Немає шляху від кореня до листа з sum = 5.\n\n### Приклад 3:\n> **Ввід:** root = [], targetSum = 0\n> **Вивід:** false\n> **Пояснення:** Оскільки дерево порожнє, немає шляхів від кореня до листа.\n\n### Обмеження:\n* Кількість вузлів у дереві знаходиться в діапазоні `[1, 5000]`.\n* `-1000 <= Node.val <= 1000`\n* `-1000 <= targetSum <= 1000`\n \nУ своєму рішенні я використовую метод DFS для обходу бінарного дерева, рекурсивний варіант. На кожному кроці `targetSum` зменшується на значення поточного `node.val`. Коли алгоритм досягає листа виконується порівння `node.val` з залишковим `targetSum`, якщо вони рівні, то `true` стає результатом.\nКод рішення наведено нижче:\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {boolean}\n */\nvar hasPathSum = function(root, sum) {\n    if (!root) return false;\n\n    if (!root.left && !root.right) { // check leaf\n        return sum === root.val;\n    } else { // continue DFS\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\n    }\n};\n```\n"
        },
        {
            "date": "2023-09-16",
            "status": "successful",
            "title": "Path Sum II",
            "text": "Дано `root` бінарного дерева та ціле число `targetSum`, повернути *всі шляхи **від кореня до листа**, де сума значень вузлів у шляху дорівнює `targetSum`. Кожен шлях має повертатися як список **значень** вузлів, а не посилань на вузли*.\nШлях **від кореня до листа** — це шлях, що починається від кореня і закінчується будь-яким листовим вузлом. **Листок** — це вузол без дітей.\n#cut\n### Приклад 1:\n![Binary tree](https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg)\n> **Ввід:** root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n> **Вивід:** [[5,4,11,2],[5,8,4,5]]\n> **Пояснення:** Є два шляхи, сума яких дорівнює targetSum:\n> 5 + 4 + 11 + 2 = 22\n> 5 + 8 + 4 + 5 = 22\n\n### Приклад 2:\n![Small binary tree](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)\n> **Ввід:** root = [1,2,3], targetSum = 5\n> **Вивід:** []\n\n### Приклад 3:\n> **Ввід:** root = [1,2], targetSum = 0\n> **Вивід:** []\n\n### Обмеження:\n* Кількість вузлів у дереві знаходиться в діапазоні `[1, 5000]`.\n* `-1000 <= Node.val <= 1000`\n* `-1000 <= targetSum <= 1000`\n \nВ моєму рішенні знову використовується рекурсивна реалізація методу обходу бінарного дерева DFS. Коли програма досягає листка, то йде перевірка а рівність пройденого шляху та цільової суми і у разі рівності у результуючий масив додається поточний шлях у вигляді масиву.\nКод рішення наведено нижче:\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {number[][]}\n */\nvar pathSum = function(root, targetSum) {\n    if (root === null) return [];\n\n    const result = [];\n\n    dfs(root, targetSum, []);\n\n    function dfs(node, sum, path) {\n\n        if (node.left === null && node.right === null && node.val === sum) {\n            result.push([...path, node.val]);\n            return;\n        }\n\n        path.push(node.val);\n        if (node.left !== null) {\n            dfs(node.left, sum - node.val, path);\n        }\n        if (node.right !== null) {\n            dfs(node.right, sum - node.val, path);\n        }\n        path.pop();\n    }\n\n    return result;\n};\n```"
        },
        {
            "date": "2023-09-17",
            "status": "fail",
            "title": "Triangle",
            "text": "Дано масив `triangle`, поверніть *мінімальну суму шляху зверху вниз*.\nДля кожного кроку, ви можете переходити до сусіднього номера рядка нижче. Більш формально, якщо ви перебуваєте під індексом `i` у поточному рядку, ви можете перейти або до індексу `i`, або до індексу `i + 1` у наступному рядку.\n#cut\n### Приклад 1:\n> **Ввід:** triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n> **Вивід:** 11\n> **Пояснення:** Трикутник виглядає як:\n> &ensp;&ensp; _2_\n> &ensp; _3_ 4\n> &ensp;6 _5_ 7\n> 4 _1_ 8 3\n> Мінімальна сума шляху зверху вниз дорівнює 2 + 3 + 5 + 1 = 11 (підкреслено вище).\n\n### Приклад 2:\n> **Ввід:** triangle = [[-10]]\n> **Вивід:** -10\n\n### Обмеження:\n* `1 <= triangle.length <= 200`\n* `triangle[0].length == 1`\n* `triangle[i].length == triangle[i - 1].length + 1`\n* |{|-10^4^ <= triangle[i][j] <= 10^4^|}|\n \n**Подальші дії**: Чи можете ви зробити це, використовуючи лише `O(n)` додаткової пам'яті, де `n` – загальна кількість рядків у трикутнику?\n\nТак, це завдання medium-рівня, з яким я не впорався. Важкість полягає у тому, що якщо намагатися пройти трикутник згори, то не має однозначного шляху з мінімальною сумою. Тобто можна йти по суміжним елементам, обираючи кожного разу мінімальний, але сума шляха виявиться не мінімальною, бо десь збоку залишились кілька елементів з меншими значеннями. А тому на думку одразу приходить дерево рішень, що сильно ускладнить програму. Тому, подивившись в Solution, я побачив цікаве рішення, яке за один прохід, але знизу, знаходить вірну відповідь. Додаткова пам'ять при цьому не задіяна, тому що вхідний масив змінюється на місці. Рішення наведено нижче:\n```js\n/**\n * @param {number[][]} triangle\n * @return {number}\n */\nvar minimumTotal = function(T) {\n    for (let i = T.length - 2; i !== -1; i--) \n        for (let j = T[i].length - 1; j !== -1; j--) {\n            T[i][j] += Math.min(T[i+1][j], T[i+1][j+1]);\n        }\n    return T[0][0]\n}\n```\n"
        },
        {
            "date": "2023-09-18",
            "status": "fail",
            "title": "Convert Sorted Array to Binary Search Tree",
            "text": "*[збалансованою висотою]: Бінарне дерево зі збалансованою висотою — це бінарне дерево, у якому глибина двох піддерев кожного вузла ніколи не відрізняється більш ніж на одиницю.\nДано цілочисельний масив `nums`, де елементи відсортовані в **порядку зростання**, перетворіть *його на двійкове дерево пошуку зі **збалансованою висотою***.\n#cut\n### Приклад 1:\n![Двійкове дерево пошуку](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)\n> **Ввід:** nums = [-10,-3,0,5,9]\n> **Вивід:** [0,-3,9,-10,null,5]\n> **Пояснення**: [0,-10,5,null,-3,null,9] також приймається:\n> ![Двійкове дерево пошуку](https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg)\n\n### Приклад 2:\n![Двоє двійкових дерев пошуку](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)\n> **Ввід:** nums = [1,3]\n> **Вивід:** [3,1]\n> **Пояснення**: [1,null,3] і [3,1] обидва є BST зі збалансованою висотою.\n\n### Обмеження:\n* |{|1 <= nums.length <= 10^4^|}|\n* |{|-10^4^ <= nums[i] <= 10^4^|}|\n* `nums` сортується в **строгому порядку зростання**.\n \nЦе завдання я також не зміг зробити самостійно, натомість розглянув рішення з Solutions.\nЗадача вирішується розбиванням масиву навпіл рекурсивно. При цьому кожного разу створюється вузол дерева зі значенням середнього елементу масиву, а його лівий та правий потомки формуються з передаваних підмасивів. Рекурсія продовжується поки передаванийй підмасив не стане одним елементом. Код рішення наведено нижче:\n \n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} nums\n * @return {TreeNode}\n */\nvar sortedArrayToBST = function(nums) {\n// Call the function recursively...\n    return ConvToBST(nums, 0, nums.length - 1);\n}\n// Create a function which will convert any particular range of given nums array...\n// & return its corresponding BST root node....\nvar ConvToBST = function(nums, beg, end) {\n// If beg > end, return NULL, as we receive a wrong range...\n    if (beg > end)\n        return null;\n// set the middle node...\n    var mid = Math.ceil((beg + end) / 2);\n// Initialise root node with value same as nums[mid]...\n    var root = new TreeNode(nums[mid]);\n// Assign left subtrees as the same function called on left subranges...\n    root.left = ConvToBST(nums, beg, mid - 1);\n// Assign right subtrees as the same function called on right subranges...\n    root.right = ConvToBST(nums, mid + 1, end);\n// Return the root node...\n    return root;\n};\n```"
        },
        {
            "date": "2023-09-19",
            "status": "problem",
            "title": "Convert Sorted List to Binary Search Tree",
            "text": "*[збалансованою висотою]: Бінарне дерево зі збалансованою висотою — це бінарне дерево, у якому глибина двох піддерев кожного вузла ніколи не відрізняється більш ніж на одиницю.\nДано заголовок однозв’язаного списку, де елементи відсортовані в **порядку зростання**, перетворіть *його на двійкове дерево пошуку зі **збалансованою висотою***.\n#cut\n### Приклад 1:\n![Двійкове дерево пошуку](https://assets.leetcode.com/uploads/2020/08/17/linked.jpg)\n> **Ввід:** head = [-10,-3,0,5,9]\n> **Вивід:** [0,-3,9,-10,null,5]\n> **Пояснення**: Однією з можливих відповідей є [0,-3,9,-10,null,5], що представляє показану BST із збалансованою висотою.\n\n### Приклад 2:\n> **Ввід:** head = []\n> **Вивід:** []\n\n### Обмеження:\n* Кількість вузлів у `head` знаходиться в діапазоні |{|[0, 2 * 10^4^]|}|.\n* |{|-10^5^ <= Node.val <= 10^5^|}|\n \nРішення подібне до **Convert Sorted Array to Binary Search Tree**, але спочатку за один прохід по списку формується масив `nums`, який передається до функції ConvToBSD.\nАле якщо подивитись у Solutions, то є більш цікаве рішення без допоміжного масиву:\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    let curr = head, count = 0\n    while (curr) curr = curr.next, count++\n    const treeify = (i, j) => {\n        if (j < i) return null\n        let mid = i + j >> 1, node = new TreeNode()\n        node.left = treeify(i, mid - 1)\n        node.val = curr.val, curr = curr.next\n        node.right = treeify(mid + 1, j)\n        return node\n    }\n    curr = head\n    return treeify(1, count)\n};\n```"
        },
        {
            "date": "2023-09-20",
            "status": "successful",
            "title": "Balanced Binary Tree",
            "text": "*[збалансованим за висотою]: Бінарне дерево зі збалансованою висотою — це бінарне дерево, у якому глибина двох піддерев кожного вузла ніколи не відрізняється більш ніж на одиницю.\nДано бінарне дерево, визначте, чи є воно **збалансованим за висотою**.\n#cut\n### Приклад 1:\n![Height-balanced binary tree](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\n> **Ввід:** root = [3,9,20,null,null,15,7]\n> **Вивід:** true\n\n### Приклад 2:\n![Height-disbalanced binary tree](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)\n> **Ввід:** root = [1,2,2,3,3,null,null,4,4]\n> **Вивід:** false\n\n### Приклад 3:\n> **Ввід:** root = []\n> **Вивід:** true\n\n### Обмеження:\n* Кількість вузлів у дереві знаходиться в діапазоні `[0, 5000]`.\n* |{|-10^4^ <= Node.val <= 10^4^|}|\n \nРішення таке: \n- обходимо двійкове дерево за методом DFS рекурсивно;\n- кожен вузел перевіряється на відповідність умовам;\n- функція dfs повертає глибину вузла, або `-1` якщо перевірка не пройдена; \n- якщо десь буде повернена `-1`, то початковий виклик dfs(root) теж поверне `-1`.\n \n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\n\nvar isBalanced = function(root) {\n    if (root === null) return true;\n        return (dfs(root) !== -1)\n};\n\nfunction dfs(node) {\n    if (node === null) {\n        return 0;\n    }\n\n    let l = 0, r = 0.\n    if (node.left !== null) {\n        l = dfs(node.left)\n    } \n    if (node.right !== null) {\n        r = dfs(node.right);\n    }\n    \n    if (l === -1 || r === -1 || Math.abs(l - r) > 1) return -1;\n\n    return 1 + Math.max(l, r);\n};\n```\n"
        },
        {
            "date": "2023-09-21",
            "status": "fail",
            "title": "Single Number",
            "text": "Дано **непорожній** масив цілих чисел `nums` кожен елемент з’являється *двічі*, крім одного. Знайдіть той єдиний елемент.\nВи повинні реалізувати рішення з лінійною складністю часу виконання та використовувати лише постійний додатковий простір.\n#cut\n### Приклад 1:\n> **Ввід:**  nums = [2,2,1]\n> **Вивід:** 1\n\n### Приклад 2:\n> **Ввід:** nums = [4,1,2,1,2]\n> **Вивід:** 4\n\n### Приклад 3:\n> **Ввід:** nums = [1]\n> **Вивід:** 1\n\n### Обмеження:\n* |{|1 <= nums.length <= 3 * 10^4^|}|\n* |{|-3 * 10^4^ <= nums[i] <= 3 * 10^4^|}|\n* Кожен елемент у масиві з’являється двічі, за винятком одного елемента, який з’являється лише один раз.\n \n\nРішення цієї задачі я подивився на Solutions тому, що окрім звичайного пошуку, який тут нефективний, нічого не придумав. Виявляється такого роду пошук ефективно виконується завдяки побітовим операціям, а особливо XOR. Наведене рішення засновано на тому що `a xor a xor b = b`. Тобто, якщо послідовно пройти по масиву зробити суму за модулем 2 всіх елементів, то парні числа не залишаться у результаті, а залишиться тільке число без пари.\n\n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\nvar singleNumber = function(nums) {\n    // Initialize the unique number...\n    let uniqNum = 0;\n    // TRaverse all elements through the loop...\n    for (let idx = 0; idx < nums.length; idx++) {\n        // Concept of XOR...\n        uniqNum = uniqNum ^ nums[idx];\n    } return uniqNum;       // Return the unique number...\n};\n```"
        },
        {
            "date": "2023-09-22",
            "status": "fail",
            "title": "Single Number II",
            "text": "Дано цілочисельний масив `nums`, де кожен елемент з’являється **тричі**, за винятком одного, який з’являється **рівно один раз**. *Знайдіть єдиний елемент і поверніть його*.\nВи повинні реалізувати рішення з лінійною складністю часу виконання та використовувати лише постійний додатковий простір.\n#cut\n### Приклад 1:\n> **Ввід:**  nums = [2,2,3,2]\n> **Вивід:** 3\n\n### Приклад 2:\n> **Ввід:** nums = [0,1,0,1,0,1,99]\n> **Вивід:** 99\n\n\n\n### Обмеження:\n* |{|1 <= nums.length <= 3 * 10^4^|}|\n* |{|-2^31^ <= nums[i] <= 2^31^ - 1|}|\n* Кожен елемент у масиві з’являється **тричі**, за винятком одного елемента, який з’являється лише **один раз**.\n \nРішення цієї задачі я подивився на Solutions тому, що окрім звичайного пошуку, який тут нефективний, нічого не придумав. Виявляється такого роду пошук ефективно виконується завдяки побітовим операціям, а особливо XOR. Рішення првцює з двома змінними: `ones` для фіксації бітів які з'явились один раз, та `twos` для фіксації тих бітів які зустрілись двічі. \nАлгоритм наступний:\n1. Ініціалізуйте `ones` та `twos` як `0`.\n2. Переберіть кожне число `num` у вхідному масиві `nums`.\n3. Оновіть одиниці та двійки за допомогою побітових операцій:\n    - `ones = (ones ^ num) & ~twos`: XOR поточне число `num` з `ones`, щоб перемикати біти, які з'являються один раз, потім виконайте побітове AND з доповненням `twos`, щоб видалити біти, які з'являються двічі.\n    - `twos = (twos ^ num) & ~ones`: XOR поточне число `num` з `twos`, щоб перемикати біти, які з'являються двічі, потім виконайте побітове AND з доповненням `ones`, щоб видалити біти, які з'являються один раз.\n4. Після повторення всіх чисел значення, збережене в `ones`, буде одним числом, яке з’являється лише один раз.\n5. Повернути значення `ones` як результат.\n \n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n    let ones = 0;\n    let twos = 0;\n\n    for (let num of nums) {\n        ones = (ones ^ num) & ~twos;\n        twos = (twos ^ num) & ~ones;\n    }\n    return ones;\n};\n```"
        },
        {
            "date": "2023-09-23",
            "status": "successful",
            "title": "Convert Sorted List to Binary Search Tree",
            "text": "*[збалансованою висотою]: Бінарне дерево зі збалансованою висотою — це бінарне дерево, у якому глибина двох піддерев кожного вузла ніколи не відрізняється більш ніж на одиницю.\nДано `head` однозв’язаного списоку, де елементи відсортовані в **порядку зростання**, *перетворіть його на двійкове дерево пошуку зі **збалансованою висотою***.\n#cut\n### Приклад 1:\n![Conversioning the Linked List into the Height-Balanced Binary Tree](https://assets.leetcode.com/uploads/2020/08/17/linked.jpg)\n> **Ввід:** head = [-10,-3,0,5,9]\n> **Вивід:** [0,-3,9,-10,null,5]\n> **Пояснення:** Однією з можливих відповідей є [0,-3,9,-10,null,5], що представляє показану BST із збалансованою висотою. \n\n### Приклад 2:\n> **Ввід:** head = []\n> **Вивід:** []\n\n### Обмеження:\n* Кількість вузлів у `head` знаходиться в діапазоні |{|[0, 2 * 10^4^]|}|\n* |{|-10^5^ <= Node.val <= 10^5^|}|\n \nТут ідея проста: спочатку формуємо масив, а потім по ньому вже створюється двійкове дерево пошуку. Код рішення наведено нижче\n \n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    const nums = [];\n    let curr = head;\n    while (curr !== null) {\n        nums.push(curr.val);\n        curr = curr.next;\n    }\n    return ConvToBST(nums, 0, nums.length -1 );\n};\n\nvar ConvToBST = function(nums, beg, end) {\n\n    if (beg > end)\n        return null;\n\n    var mid = Math.ceil((beg + end) / 2);\n    var root = new TreeNode(nums[mid]);\n    root.left = ConvToBST(nums, beg, mid - 1);\n    root.right = ConvToBST(nums, mid + 1, end);\n    return root;\n};\n```"
        },
        {
            "date": "2023-09-24",
            "status": "problem",
            "title": "Linked List Cycle",
            "text": "Дано `head`, голова зв’язаного списку, визначає, чи містить зв’язаний список цикл.\nУ зв’язаному списку існує цикл, якщо в списку є якийсь вузол, до якого можна знову повернутися, постійно переходячи за вказівником `next`. Внутрішньо `pos` використовується для позначення індексу вузла, до якого підключено вказівник хвоста `next`. **Зауважте, що** `pos` **не передається як параметр**.\nПоверніть `true`, *якщо у пов’язаному списку є цикл*. В іншому випадку поверніть `false`.\n#cut\n### Приклад 1:\n![Linked List with the cycle](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n> **Ввід:** head = [3,2,0,-4], pos = 1\n> **Вивід:** true\n> **Пояснення:** У пов’язаному списку є цикл, де хвіст з’єднується з 1-м вузлом (з індексом 0). \n\n### Приклад 2:\n![Short Linked List with the cycle](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)\n> **Ввід:** head = [1,2], pos = 0\n> **Вивід:** true\n> **Пояснення:** У пов’язаному списку є цикл, де хвіст з’єднується з 0-м вузлом.\n\n\n### Приклад 3:\n![List of One Node](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)\n> **Ввід:** head = [1], pos = -1\n> **Вивід:** false\n> **Пояснення:** У пов’язаному списку немає жодного циклу.\n\n### Обмеження:\n* Кількість вузлів у списку знаходиться в діапазоні|{|[0, 10^4^]|}|\n* |{|-10^5^ <= Node.val <= 10^5^|}|\n* `pos` дорівнює `-1` або **дійсний індекс** у пов’язаному списку.\n \n**Подальші дії**: чи можете ви розв’язати її, використовуючи `O(1)` (тобто постійну) пам’ять?\n\nСпочатку я зробив варіант з Set. Працює досить швидко, але потребує додаткового простору. Тому подивився в Solutions, як то треба було зробити. Побачив цікаве рішення, де використовується два вказівника, \"звичайний\" та \"швидкий\". Звичайний - за одну ітерацію робить один перехід вперед, а швидкий - одазу два. Якщо у списку є цикл, то колись швидкий вказівник \"наздожене\" звичайний вказівник. Тому вони постійно порівнюються між собою. Або якщо циклу немає, то буде досягнуто кінець списку. Код рішення наведено нижче.\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nvar hasCycle = function(head) {\n    let fast = head;\n    while (fast && fast.next) {\n        head = head.next;\n        fast = fast.next.next;\n        if (head === fast) return true;\n    }\n    return false;\n}\n```\n"
        },
        {
            "date": "2023-09-25",
            "status": "successful",
            "title": "Happy Number",
            "text": "Напишіть алгоритм, щоб визначити, чи є число `n` щасливим.\n**Щасливе число** — це число, яке визначається наступним чином:\n* Починаючи з будь-якого натурального числа, замініть число сумою квадратів його цифр.\n* Повторюйте процес, доки число не дорівнюватиме 1 (де воно залишиться), або він **нескінченно зациклюється в циклі**, який не включає 1. \n* Ті числа, для яких цей процес **завершується на 1**, щасливі.\n \nПоверніть `true`, якщо `n` є щасливим числом, і `false`, якщо ні.\n#cut\n### Приклад 1:\n> **Ввід:** n = 19\n> **Вивід:** true\n> **Пояснення:**\n> 1^2^ + 9^2^ = 82\n> 8^2^ + 2^2^ = 68\n> 6^2^ + 8^2^ = 100\n> 1^2^ + 0^2^ + 0^2^ = 1\n\n### Приклад 2:\n> **Ввід:** n = 2\n> **Вивід:** false\n\n### Обмеження:\n* |{|1 <= n <= 2^31^ - 1|}|\n \nНаводжу свій варіант вирішення проблеми. Set не використовується. Замість нього дві поточних суми - поточна і швидка. У разі якщо буде зациклений цикл, то ці дві суми зрівняються.\nЗвичайно тут можна використати Set, а також масив з реультатами квадратів чисел від 0 до 9. \n \n```js\n/**\n * @param {number} n\n * @return {boolean}\n */\nconst calcSquaresSum = function(x) {\n    return x.toString().split(\"\").reduce((acc, curr) => acc + curr**2 , 0);\n}\n\nconst isHappy = function(n) {\n    if (calcSquaresSum(n) === 1) return true;\n    let current = n, fast = n;\n    while(current !== 1 && fast !== 1 ) {\n        current = calcSquaresSum(current);\n        fast = calcSquaresSum(calcSquaresSum(fast));\n        if (current === fast) return false;\n    }\n    return true;\n};\n```"
        },
        {
            "date": "2023-09-26",
            "status": "successful",
            "title": "Ugly Number",
            "text": "Потворне число — це **натуральне число**, прості множники якого обмежені `2`, `3` і `5`.\nДано ціле число `n`, поверніть `true`, *якщо `n` є **потворним числом***.\n#cut\n### Приклад 1:\n> **Ввід:** n = 6\n> **Вивід:** true\n> **Пояснення:** 6 = 2 × 3\n\n\n### Приклад 2:\n> **Ввід:** n = 1\n> **Вивід:** true\n> **Пояснення:** 1 не має простих множників, тому всі його прості множники обмежені 2, 3 і 5.\n\n### Приклад 3:\n> **Ввід:** n = 14\n> **Вивід:** false\n> **Пояснення:** 14 не є потворним, оскільки містить простий множник 7.\n\n### Обмеження:\n* |{|-2^31^ <= n <= 2^31^ - 1|}|\n \nРішення полягає в тому, що треба виконати поділ числа `n` на `2` у циклі поки воно ділиться без залишку, потім так само на `3` та `5`. Чи дорівнює залишок `1` і є результатом.\nКод рішення наведено нижче:\n```js\n/**\n * @param {number} n\n * @return {boolean}\n */\n\nconst maxDivide = function(a , b) {\n    while (a % b === 0)\n        a = a / b;\n    return a;\n}\n \nconst isUgly = function(n) {\n    if (n < 1) return false;\n    n = maxDivide(n, 2);\n    n = maxDivide(n, 3);\n    n = maxDivide(n, 5);\n \n    return (n === 1) ? 1 : 0;\n};\n```"
        },
        {
            "date": "2023-09-27",
            "status": "fail",
            "title": "Ugly Number II",
            "text": "**Потворне число** — це натуральне число, прості множники якого обмежені `2`, `3` і `5`.\nДано ціле число `n`, поверніть |{|n^-е^|}| потворне число.\n#cut\n### Приклад 1:\n> **Ввід:** n = 10\n> **Вивід:** 12\n> **Пояснення:** [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] це послідовність перших 10 потворних чисел.\n\n### Приклад 2:\n> **Ввід:** n = 1\n> **Вивід:** 1\n> **Пояснення:** 1 не має простих множників, тому всі його прості множники обмежені 2, 3 і 5.\n\n### Обмеження:\n* `1 <= n <= 1690`\n \nЯкщо спробувати просто у циклі інкрементувати лічильник та кожного разу його перевіряти на \"потворність\" то такий підхід дуже важкий за кількісттю обчислень. Тому потрібен інший підхід. Потрібно кожне наступне потворне число знаходити одразу, без зайвих обчислень.\nПодальші пояснення узяті з Solutions.\nПотворна послідовність чисел — це 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, … тому що кожне число можна поділити лише на 2, 3, 5, можна інакше поглянути на послідовність - розділити послідовність на три групи, як показано нижче:\n(1) 1×2, 2×2, 3×2, 4×2, 5×2, …\n(2) 1×3, 2×3, 3×3, 4×3, 5×3, …\n(3) 1×5, 2×5, 3×5, 4×5, 5×5, …\nМи можемо помітити, що кожна підпослідовність є сама потворною послідовністю (1, 2, 3, 4, 5, …) помножені на 2, 3 чи 5.\nТоді використаємо подібний метод злиття, як сортування злиттям, щоб отримати кожне потворне число з трьох підпослідовностей.\nНа кожному кроці ми обираємо найменше число і переходимо на наступний крок, включаючи числа з однаковим значенням.\nРеалізація цієї ідеї наведена нижче:\n```js\n/**\n * @param {number} n\n * @return {number}\n */\nfunction nthUglyNumber(n) {\n\n    const ugly = new Array(n);\n    ugly[0] = 1;\n    let index2 = 0, index3 = 0, index5 = 0;\n    let factor2 = 2, factor3 = 3, factor5 = 5;\n    for(let i = 1; i < n; i++){\n        const min = Math.min(Math.min(factor2, factor3), factor5);\n        ugly[i] = min;\n        if (factor2 === min)\n            factor2 = 2*ugly[++index2];\n        if (factor3 === min)\n            factor3 = 3*ugly[++index3];\n        if (factor5 === min)\n            factor5 = 5*ugly[++index5];\n    }\n    return ugly[n-1];\n    \n} \n```"
        },
        {
            "date": "2023-09-28",
            "status": "problem",
            "title": "Add Digits",
            "text": "Дано ціле число `num`, кілька разів додайте всі його цифри, поки в результаті не буде лише одна цифра, і поверніть її.\n#cut\n### Приклад 1:\n> **Ввід:** num = 38\n> **Вивід:** 2\n> **Пояснення:** Процес є\n> 38 --> 3 + 8 --> 11 \n> 11 --> 1 + 1 --> 2 \n> Оскільки 2 має лише одну цифру, поверніть її.\n\n### Приклад 2:\n> **Ввід:** num = 0\n> **Вивід:** 0\n\n### Обмеження:\n* |{|0 <= num <= 2^31^ - 1|}|\n \n**Подальші дії:** чи можете ви зробити це без будь-якого циклу/рекурсії за час виконання `O(1)`?\n\nТак, можна у циклі зробити за допомогою ланцюжка toString, split та reduce, але час виконання десь `O(logN)`. Тому подивившись в Solution, стало зрозуміло, як насправді треба було зробити. Виявляється що той самий ефект, якщо число більше `9` має операція взяття залишку від поділу на `9`. Код рішення:\n```js \n/**\n * @param {number} num\n * @return {number}\n */\n\n\nvar addDigits = function(num) {\n    if (isNaN(num) || num === 0) return 0;\n    if (num < 10) return num;\n    return num % 9 === 0 ? 9 : num % 9;\n};\n```\n"
        },
        {
            "date": "2023-09-29",
            "status": "successful",
            "title": "Binary Tree Paths",
            "text": "Дано `root` бінарного дерева, поверніть *всі шляхи від кореня до листка в **будь-якому порядку***.\n**Листок** — це вузол без дітей.\n#cut\n### Приклад 1:\n![Binary tree](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)\n> **Ввід:** root = [1,2,3,null,5]\n> **Вивід:** [\"1->2->5\",\"1->3\"]\n\n### Приклад 2:\n> **Ввід:** root = [1]\n> **Вивід:** [\"1\"]\n\n### Обмеження:\n* Кількість вузлів у дереві знаходиться в межах `[1, 100]`.\n* `-100 <= Node.val <= 100`\n \nЦя проблема вирішується обходом по дереву за методом DFS рекурсивно. Передається додатковий параметр у функції dfsTraversal  - строка з поточним шляхом. Коли алгоритм досягає листка, ця строка додається до масиву результатів.\nКод рішення наведено нижче:\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {string[]}\n */\n\nvar binaryTreePaths = function(root) {\n    let paths = [];\n    \n    function dfsTraversal(root, cur) {\n        if (!root) return;\n        if (!root.left && !root.right) {\n            paths.push(cur + root.val);\n            return;\n        }\n        dfsTraversal(root.left, cur + root.val + \"->\");\n        dfsTraversal(root.right, cur + root.val + \"->\");\n    }\n    \n    dfsTraversal(root, \"\");\n    return paths;\n\n};\n```"
        },
        {
            "date": "2023-09-30",
            "status": "fail",
            "title": "Binary Tree Preorder Traversal",
            "text": "Дано `root` бінарного дерева, повернути *префіксний обхід значень його вузлів*.\n#cut\n### Приклад 1:\n![Binary tree](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)\n> **Ввід:** root = [1,null,2,3]\n> **Вивід:** [1,2,3]\n \n### Приклад 2:\n> **Ввід:** root = []\n> **Вивід:** []\n \n### Приклад 3:\n> **Ввід:** root = [1]\n> **Вивід:** [1]\n \n### Обмеження:\n* Кількість вузлів у дереві знаходиться в межах `[1, 100]`.\n* `-100 <= Node.val <= 100`\n \n**Подальші дії:** Рекурсивне рішення є тривіальним, чи могли б ви зробити це ітеративно? \n\nОбхід дерева — це послідовна обробка (перегляд, зміна тощо) усіх вузлів дерева, при якій кожен вузол обробляється рівно один раз. Це призводить до лінійного розташування вузлів дерева.\nЗалежно від траєкторій розрізняють два види обходу: - горизонтальний (широкий); і - вертикальний (в глибину).\nГоризонтальний обхід передбачає обхід дерева за рівнями (упорядковано за рівнем) - спочатку обробляються всі вузли поточного рівня, після чого здійснюється перехід на нижчий рівень.\nПід час вертикального обходу порядок обробки поточного вузла та вузлів його правого та лівого піддерев змінюється, і на основі цього критерію розрізняють три варіанти вертикального обходу:\n- прямий (префіксний, попередньо впорядкований): вершина - ліве піддерево – праве піддерево; \n- зворотній (інфіксний, впорядкований): ліве піддерево – вершина – праве піддерево; і \n- кінцевий (постфіксний, поступорядкований): ліве піддерево - праве піддерево - вершина.\n \nІ якщо рекурсивний обхід бінарним деревом дійсно легко реалізувати, то от ітеративно це вже менш трівіальна задача. \n\nВертикальний прямий обхід: обробляємо поточний вузол, якщо є праве піддерево, додаємо його в стек для подальшої обробки. Переходимо до вузла лівого піддерева. Якщо лівого вузла немає, переходимо до верхнього вузла зі стеку.\n\nКод рішення наведено нижче:\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function(root) {\n    const stack = [], result = [];\n    let curr = root;\n\n    while (curr !== null || stack.length > 0){\n        if (stack.length > 0){\n            curr=stack.pop();\n        }\n        while (curr !== null){\n            result.push(curr.val);\n            if (curr.right!=null) {\n                stack.push(curr.right); \n            }\n            curr=curr.left;\n        }\n    }\n    return result;\n}\n```"
        },
        {
            "date": "2023-10-01",
            "status": "problem",
            "title": "N-ary Tree Preorder Traversal",
            "text": "Дано `root` n-арного дерева, повернути префіксний обхід значень його вузлів.\nСеріалізація вхідних даних n-арного дерева представлена ​​у порівневому порядку обхіду. Кожна група дітей відокремлена null-значенням (див. приклади)\n#cut\n### Приклад 1:\n![Nary-Tree](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png =300x)\n> **Ввід:** root = [1,null,3,2,4,null,5,6]\n> **Вивід:** [1,3,5,6,2,4]\n\n### Приклад 2:\n![Nary-Tree](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png =300x)\n> **Ввід:** root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n> **Вивід:** [1,2,3,6,7,11,14,4,8,12,5,9,13,10]\n\n### Обмеження:\n* Кількість вузлів у дереві знаходиться в діапазоні |{|[0, 10^4^]|}|.\n* |{|0 <= Node.val <= 10^4^|}|\n* Висота n-арного дерева менше або дорівнює `1000`.\n \n**Подальші дії:** Рекурсивне рішення є тривіальним, чи могли б ви зробити це ітеративно? \n\nВід **Binary Tree Preorder Traversal** алгоритм відрізняється тим, що спершу у стек додаються усі нащадки у зворотньому порядку,  окрім 0-го, а далі йде перехід на 0-го нащадка. \nКод рішення наведено нижче:\n```js\n/**\n * // Definition for a Node.\n * function Node(val, children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\n/**\n * @param {Node|null} root\n * @return {number[]}\n */\nvar preorder = function(root) {\n    const stack = [], values = [];\n    let curr = root;\n\n    while (curr || stack.length > 0) {\n        if (stack.length > 0) {\n            curr = stack.pop();\n        }\n        while (curr) {\n            values.push(curr.val);\n            if (curr.children) {\n                for (let i = curr.children.length - 1; i > 0; i--) {\n                    if (curr.children[i]) {\n                        stack.push(curr.children[i]);\n                    }\n                }\n            } \n        curr = curr.children[0];\n        }\n    }\n    return values;\n};\n```"
        },
        {
            "date": "2023-10-02",
            "status": "fail",
            "title": "N-ary Tree Postorder Traversal",
            "text": "Дано `root` n-арного дерева, повернути *постфіксний обхід значень його вузлів*.\nСеріалізація вхідних даних n-арного дерева представлена у порівневому порядку обхіду. Кожна група дітей відокремлена null-значенням (див. приклади)\n#cut\n### Приклад 1:\n![Nary-Tree](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)\n> **Ввід:** root = [1,null,3,2,4,null,5,6]\n> **Вивід:** [5,6,3,2,4,1]\n\n### Приклад 2:\n![Nary-Tree](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)\n> **Ввід:** root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n> **Вивід:** [2,6,14,11,7,3,12,8,4,13,9,10,5,1]\n\n### Обмеження:\n* Кількість вузлів у дереві знаходиться в діапазоні |{|[0, 10^4^]|}|.\n* |{|0 <= Node.val <= 10^4^|}|\n* Висота n-арного дерева менше або дорівнює `1000`.\n \n**Подальші дії:** Рекурсивне рішення є тривіальним, чи могли б ви зробити це ітеративно? \n\nРекурсію реалізувати не складно, а от реалізація ітеративного алгоритму викликає ступор. Знайшов у Solushions правильну реалізацію з запам'ятовуванням відвіданих вузлів.\n\n \n```js\n/**\n * // Definition for a Node.\n * function Node(val,children) {\n *    this.val = val;\n *    this.children = children;\n * };\n */\n\n/**\n * @param {Node|null} root\n * @return {number[]}\n */\nfunction postorder(root) {\n    if (!root) return []\n    \n    const answer = []\n    const stack = []\n    \n    stack.push(root)\n    let lastVisited = null\n    \n    while (stack.length > 0) {\n        const node = stack[stack.length - 1]\n        \n        const children = node.children\n        const length = children.length\n\n        // if the rightmost child has been visited, then it means all children have been visited\n        const hasVisitedChildren = children[length - 1] === lastVisited\n        \n        if (!hasVisitedChildren && length > 0) \n            // pushing to the stack in reverse order\n            for (let i = length - 1; i >= 0; i--) stack.push(children[i])\n        \n        else {    \n            // if the node has no children or if its children have already been visited, we visit the node\n            stack.pop()\n            answer.push(node.val)\n            lastVisited = node\n        }\n    }\n    \n    return answer\n};\n```"
        },
        {
            "date": "2023-10-03",
            "status": "fail",
            "title": "Binary Tree Postorder Traversal",
            "text": "Дано `root` бінарного дерева, поверніть постфіксний обхід значень його вузлів.\n#cut\n### Приклад 1:\n![Binary tree](https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg)\n> **Ввід:** root = [1,null,2,3]\n> **Вивід:** [3,2,1]\n \n### Приклад 2:\n> **Ввід:** root = []\n> **Вивід:** []\n \n### Приклад 3:\n> **Ввід:** root = [1]\n> **Вивід:** [1]\n \n### Обмеження:\n* Кількість вузлів у дереві знаходиться в межах `[1, 100]`.\n* `-100 <= Node.val <= 100`\n \n**Подальші дії:** Рекурсивне рішення є тривіальним, чи могли б ви зробити це ітеративно? \n\nВертикальний зворотний обхід: від поточного вузла ми «спускаємося» до найнижчого лівого вузла, додаючи всі відвідані вузли в стек. Обробляємо верхній вузол зі стека. Якщо поточний вузол має праве піддерево, ми починаємо наступну ітерацію з правого вузла. Якщо правого вузла немає, ми пропускаємо крок спуску і переходимо до обробки наступного вузла зі стеку.\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar postorderTraversal = function(root) {\n    const stack = [], result = [];\n    let curr = root;\n\n    while (curr || stack.length){\n        if (stack.length) {\n            curr = stack.pop();\n            if (stack.length && curr.right == stack.at(-1)){\n                curr = stack.pop();\n            } else {\n                result.push(curr.val);\n                curr = null;\n            }\n        }\n        while (curr) {\n            stack.push(curr);\n            if (curr.right !== null) {\n                stack.push(curr.right);\n                stack.push(curr);\n            }\n            curr = curr.left;\n         }\n    }\n    return result;\n};\n```"
        },
        {
            "date": "2023-10-04",
            "status": "successful",
            "title": "Excel Sheet Column Title",
            "text": "Дано ціле число `columnNumber`, повернути *його відповідний заголовок стовпця, як він відображається на аркуші Excel*.\n#cut\nНаприклад:\n\n> A -> 1\n> B -> 2\n> C -> 3\n> ...\n> Z -> 26\n> AA -> 27\n> AB -> 28 \n> ...\n\n### Приклад 1:\n> **Ввід:** columnNumber = 1\n> **Вивід:** \"A\"\n \n### Приклад 2:\n> **Ввід:** columnNumber = 28\n> **Вивід:** \"AB\"\n \n### Приклад 3:\n> **Ввід:** columnNumber = 701\n> **Вивід:** \"ZY\"\n \n### Обмеження:\n* |{|1 <= columnNumber <= 2^31^ - 1|}|\n \nРобота з кодами символів. Фактично треба число перевести у 26-ричну систему числення, у якій використовуються тільки 26 англійських великих літер. Написав свою реалізацію. \n```js\n/**\n * @param {number} columnNumber\n * @return {string}\n */\nvar convertToTitle = function(columnNumber) {\n    const charCodes = [];\n    let num = columnNumber; \n    while (num) {\n        num--;\n        let n = (num % 26);\n        num = ((num - n) / 26);\n        charCodes.push(n + 65);\n    }\n    return String.fromCharCode(...(charCodes.reverse()));\n};\n```"
        },
        {
            "date": "2023-10-05",
            "status": "successful",
            "title": "Excel Sheet Column Number",
            "text": "Дано рядок `columnTitle`, який представляє заголовок стовпця, який відображається на аркуші Excel, поверніть *відповідний номер стовпця*.\n#cut\nНаприклад:\n\n> A -> 1\n> B -> 2\n> C -> 3\n> ...\n> Z -> 26\n> AA -> 27\n> AB -> 28 \n> ...\n\n### Приклад 1:\n> **Ввід:** columnTitle = \"A\"\n> **Вивід:** 1\n \n### Приклад 2:\n> **Ввід:** columnTitle = \"AB\"\n> **Вивід:** 28\n \n### Приклад 3:\n> **Ввід:** columnTitle = \"ZY\"\n> **Вивід:** 701\n \n### Обмеження:\n* `1 <= columnTitle.length <= 7`\n* `columnTitle` складається тільки з великих англійських літер\n* `columnTitle` знаходиться в діапазоні `[\"A\", \"FXSHRXW\"]`. \n \nНаписав свою реалізацію. Фактично йде перекодування з 26-ричної системи числення у 10-ричну. Робота з кодами символів та степенями числа 26. \n```js\n/**\n * @param {string} columnTitle\n * @return {number}\n */\nvar titleToNumber = function(columnTitle) {\n    let result = 0;\n    power26 = [1, 26, 676, 17576, 456976, 11881376, 308915776]\n    for (let i = columnTitle.length - 1, j = 0; i > -1 ; i--, j++) {\n        result += (columnTitle.charCodeAt(i) - 64) * power26[j];\n    }\n    return result;\n};\n```"
        },
        {
            "date": "2023-10-06",
            "status": "successful",
            "title": "Cells in a Range on an Excel Sheet",
            "text": "Комірка `(r, c)` аркуша Excel представлена ​​у вигляді рядка `\"<col><row>\"`, де:\n* `<col>` позначає номер стовпця `c` комірки. Він представлений **літерами алфавіту**.\nНаприклад, `1-й` стовпець позначається буквою `'A'`, `2-й` — `'B'`, 3-й — `'C'` і так далі.\n* `<row>` — це номер рядка `r` комірки. `R-й` рядок представлено **цілим** числом `r`.\n \nВам дано рядок `s` у форматі `\"<col1><row1>:<col2><row2>\"`, де `<col1>` представляє стовпець `c1`, `<row1>` представляє рядок `r1`, `<col2>` представляє стовпець `c2`, і `<row2>` представляє рядок `r2`, такий, що `r1 <= r2` і `c1 <= c2`. \nПоверніть **список комірок** `(x, y)`, таких що `r1 <= x <= r2` і `c1 <= y <= c2`. Комірки мають бути представлені у вигляді **рядків** у форматі, згаданому вище, і бути відсортовані в порядку **неубування** спочатку за стовпцями, а потім за рядками.\n#cut\n### Приклад 1:\n<img src='https://assets.leetcode.com/uploads/2022/02/08/ex1drawio.png' alt='Cells in range' width='250' height='160'>\n\n> **Ввід:** s = \"K1:L2\"\n> **Вивід:** [\"K1\",\"K2\",\"L1\",\"L2\"]\n> **Пояснення:** \n> На наведеній вище схемі показано комірки, які повинні бути присутніми в списку. Червоні стрілки позначають порядок, у якому повинні бути представлені комірки.\n \n### Приклад 2:\n<img src='https://assets.leetcode.com/uploads/2022/02/09/exam2drawio.png' alt='Cells in row' width='500' height='50'>\n\n> **Ввід:** s = \"A1:F1\"\n> **Вивід:** [\"A1\",\"B1\",\"C1\",\"D1\",\"E1\",\"F1\"]\n> **Пояснення:** \n> На наведеній вище схемі показано комірки, які повинні бути присутніми в списку. Червона стрілка вказує порядок, у якому повинні бути представлені комірки.\n\n### Обмеження:\n* `s.length == 5`\n* `'A' <= s[0] <= s[3] <= 'Z'`\n* `'1' <= s[1] <= s[4] <= '9'`\n* `s` складається тільки з великих англійських літер, цифр та `':'`.\n \nНаписав свою реалізацію. Спочатку парситься рядок, щоб визначити на яку кількість комірок треба зміститися. Потім робиться обхід кожним стовчиком послідовно з ліва на право. У межах стовпчика у свою чергу робиться прохід зверху вниз.\n\n```js\n/**\n * @param {string} s\n * @return {string[]}\n */\nvar cellsInRange = function(s) {\n    const [startColumn, startRow, , endColumn, endRow] = s;\n    const result = [];\n    for (let i = startColumn.charCodeAt(0); i <= endColumn.charCodeAt(0); i++) {\n        for (let j = +startRow; j <= +endRow; j++) {\n            result.push(String.fromCharCode(i) + j);\n        }\n    }\n    return result;\n};\n\n```\n"
        },
        {
            "date": "2023-10-07",
            "status": "successful",
            "title": "Majority Element",
            "text": "Дано масив `nums` розміром `n`, поверніть *мажоритарний елемент*.\nМажоритарний елемент – це елемент, який з’являється більше `⌊n / 2⌋` разів. Ви можете припустити, що мажоритарний елемент завжди існує у масиві.\n#cut\n### Приклад 1:\n> **Ввід:** nums = [3,2,3]\n> **Вивід:** 3\n \n### Приклад 2:\n> **Ввід:** nums = [2,2,1,1,1,2,2]\n> **Вивід:** 2\n \n### Обмеження:\n* |{|1 <= nums.length <= 5 * 10^4^|}|\n* |{|-10^9^ <= nums[i] <= 10^9^|}|\n\n**Подальші дії:** Чи можете ви вирішити задачу в лінійному часі та в просторі `O(1)`? \n\nІснує багато можливих рішень. Як от:\n1. сортування масиву та вибір `n/2`-го елемента. Займе |{|O(n log_n_)|}| часу.\n2. переглядаючи масив один раз і зберігаючи в хеш-карті кількість входжень кожного елемента. Потім повернути елемент із хеш-карти, який мав найбільше випадків. Це займе `O(n)` місця та `O(n)` часу. Саме по такому алгоритму я написав свою реалізацію.\n3. грубий перебір, який дорівнює |{|O(n^2^)|}|\n\nОднак найоптимальнішим рішенням є використання [алгоритму більшості голосів Боєра-Мура](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm). \nУ цьому алгоритмі робота ведеться з двома змінними: 'кандидат' та 'лічильник'. Робиться один прохід масивом. Якщо поточне значення дорівнює кандидату, то лічильник збільшується на 1, інакше - зменшується на 1. При цьому, 'кандидат' змінюється на поточний елемент, якщо лічильник стане дорівнювати нулю. У результаті в змінній 'кандидат' залишаєтья мажоритарний елемет.\n\nРеалізацію найоптимальнішого рішення наведено нижче:\n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar majorityElement = function(nums) {\n    let candidate;\n    let count = 0;\n    \n    for (const num of nums) {\n        if (count === 0) {\n            candidate = num;\n        }\n        count += (num === candidate) ? 1 : -1\n    }\n    return candidate;\n};\n```"
        },
        {
            "date": "2023-10-08",
            "status": "fail",
            "title": "Majority Element II",
            "text": "Дано масив цілих чисел розміром `n`, знайти всі елементи, які з’являються більше `n/3` разів.\n#cut\n### Приклад 1:\n> **Ввід:** nums = [3,2,3]\n> **Вивід:** 3\n \n### Приклад 2:\n> **Ввід:** nums = [1]\n> **Вивід:** [1]\n\n### Приклад 3:\n> **Ввід:** nums = [1,2]\n> **Вивід:** [1,2]\n \n### Обмеження:\n* |{|1 <= nums.length <= 5 * 10^4^|}|\n* |{|-10^9^ <= nums[i] <= 10^9^|}|\n \n**Подальші дії:** Чи можете ви вирішити задачу в лінійному часі та в просторі `O(1)`? \n\nУ рішенні цієї задачі також використовується алгоритм більшості голосів Боєра-Мура, але більш ускладнений. Двоє кандидатів та двоє лічильників. Після проходу по масиву обидва кандидати додатково перевіряються на кількість голосів, якщо вона задовільна, то кандидат додається до результуючого масиву.\n\n```js\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar majorityElement = function(nums) {\n    let candidate1 = null, candidate2 = null, count1 = 0, count2 = 0;\n    \n    for (let num of nums) {\n        if (num === candidate1) {\n            count1++;\n        } else if (num === candidate2) {\n            count2++;\n        } else if (count1 === 0) {\n            candidate1 = num;\n            count1 = 1;\n        } else if (count2 === 0) {\n            candidate2 = num;\n            count2 = 1;\n        } else {\n            count1--;\n            count2--;\n        }\n    }\n    \n    count1 = count2 = 0;\n    \n    for (let num of nums) {\n        if (num === candidate1) count1++;\n        else if (num === candidate2) count2++;\n    }\n    \n    const threshold = Math.floor(nums.length / 3);\n    const result = [];\n    \n    if (count1 > threshold) result.push(candidate1);\n    if (count2 > threshold) result.push(candidate2);\n    \n    return result;\n};\n```\n"
        },
        {
            "date": "2023-10-09",
            "status": "successful",
            "title": "Reverse Bits",
            "text": "Реверсуйте біти заданого 32-бітового цілого числа без знаку.\n#cut\n**Примітка:**\n* Зауважте, що в деяких мовах, таких як Java, немає беззнакового цілого типу. У цьому випадку і вхід, і вихід будуть задані як ціле число зі знаком. Вони не повинні впливати на вашу реалізацію, оскільки внутрішнє двійкове представлення цілого числа однакове, незалежно від того, чи є воно знаком, чи без нього.\n* У Java компілятор представляє цілі числа зі знаком, використовуючи [нотацію доповнення 2](https://en.wikipedia.org/wiki/Two%27s_complement). Таким чином, у **прикладі 2** нижче, вхід представляє ціле число зі знаком `-3`, а вихід представляє ціле число зі знаком `-1073741825`.\n \n### Приклад 1:\n> **Ввід:** n = 00000010100101000001111010011100\n> **Вивід:** 964176192 (00111001011110000010100101000000)\n> **Пояснення:** Вхідний двійковий рядок **00000010100101000001111010011100** представляє ціле число без знаку 43261596, тому повертає 964176192, яке має двійкове представлення **00111001011110000010100101000000**.\n\n### Приклад 2:\n> **Ввід:** n = 11111111111111111111111111111101\n> **Вивід:** 3221225471 (10111111111111111111111111111111)\n> **Пояснення:** Вхідний двійковий рядок **11111111111111111111111111111101** представляє ціле число без знаку 43261596, тому повертає 964176192, яке має двійкове представлення **10111111111111111111111111111111**.\n \n### Обмеження:\n* Ввід має бути **двійковим рядком** довжиною `32`\n \n**Подальші дії:** якщо ця функція викликається багато разів, як би ви її оптимізували?\n \nНаписав свою реалізацію. Перетворюю число у двійковий рядок, реверсую, доповнюю нулями та перетворюю обратно у десятичне число.\n```js\n/**\n * @param {number} n - a positive integer\n * @return {number} - a positive integer\n */\nvar reverseBits = function(n) {\n    const arr = n.toString(2).split('').reverse();\n    while (arr.length < 32) {\n        arr.push('0');\n    }\n    return +('0b' + arr.join(''));\n};\n```"
        },
        {
            "date": "2023-10-10",
            "status": "successful",
            "title": "Number of 1 Bits",
            "text": "Напишіть функцію, яка приймає двійкове представлення цілого числа без знака та повертає кількість бітів '1', які воно має (також відоме як [вага Хеммінга](http://en.wikipedia.org/wiki/Hamming_weight).\n#cut\n**Примітка:**\n* Зауважте, що в деяких мовах, таких як Java, немає беззнакового цілого типу. У цьому випадку і вхід, і вихід будуть задані як ціле число зі знаком. Вони не повинні впливати на вашу реалізацію, оскільки внутрішнє двійкове представлення цілого числа однакове, незалежно від того, чи є воно знаком, чи без нього.\n* У Java компілятор представляє цілі числа зі знаком, використовуючи [нотацію доповнення 2](https://en.wikipedia.org/wiki/Two%27s_complement). Таким чином, у **прикладі 3** нижче, вхід представляє ціле число зі знаком `-3`.\n \n### Приклад 1:\n> **Ввід:** n = 00000000000000000000000000001011\n> **Вивід:** 3\n> **Пояснення:** Вхідний двійковий рядок **0000000000000000000000000001011** містить три біти '1'.\n\n### Приклад 2:\n> **Ввід:** n = 00000000000000000000000010000000\n> **Вивід:** 1\n> **Пояснення:** Вхідний двійковий рядок **00000000000000000000000010000000** містить один біт '1'.\n\n### Приклад 3:\n> **Ввід:** n = 11111111111111111111111111111101\n> **Вивід:** 31\n> **Пояснення:** Вхідний двійковий рядок **11111111111111111111111111111101** містить тридцять один біт '1'.\n \n### Обмеження:\n* Ввід має бути **двійковим рядком** довжиною `32`\n \n**Подальші дії:** якщо ця функція викликається багато разів, як би ви її оптимізували?\n\nТут йде перетворення на двійковий рядок та підрахунок символів '1'.\n```js\n/**\n * @param {number} n - a positive integer\n * @return {number}\n */\nvar hammingWeight = function(n) {\n    return n ? n.toString(2).match(/1/g).length : 0;\n};\n```"
        },
        {
            "date": "2023-10-11",
            "status": "successful",
            "title": "Hamming Distance",
            "text": "[Відстань Хеммінга](https://en.wikipedia.org/wiki/Hamming_distance) між двома цілими числами — це кількість позицій, у яких відповідні біти відрізняються.\nДано два цілих числа `x` і `y`, поверніть **відстань Хеммінга** між ними.\n#cut\n### Приклад 1:\n> **Ввід:** x = 1, y = 4\n> **Вивід:** 2\n> **Пояснення:** \n> 1&ensp;&ensp; (0 0 0 1)\n> 4&ensp;&ensp; (0 1 0 0)\n> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; ↑&ensp;&ensp; ↑\n> Наведені вище стрілки вказують на позиції, де відповідні біти відрізняються.\n\n### Приклад 2:\n> **Ввід:** x = 3, y = 1\n> **Вивід:** 1\n\n### Обмеження:\n* |{|0 <= x, y <= 2^31^ - 1|}|\n \nСвоя реалізація така: виконую `x XOR y` і в отриманому числі за допомогою побітових операцій рахую кількість одиниць.\n```js\n/**\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nvar hammingDistance = function(x, y) {\n    let num = x ^ y,  counter = 0; \n      \n    for (let i = 0; i < 32; i++) {\n        (num & 1) && counter++ ;\n        num >>>= 1;\n    }\n    return counter;\n};\n```"
        },
        {
            "date": "2023-10-12",
            "status": "problem",
            "title": "Total Hamming Distance",
            "text": "[Відстань Хеммінга](https://en.wikipedia.org/wiki/Hamming_distance) між двома цілими числами — це кількість позицій, у яких відповідні біти відрізняються.\nДано масив цілих чисел `nums`, поверніть суму **відстаней Хеммінга** між усіма парами цілих чисел у `nums`.\n#cut\n### Приклад 1:\n> **Ввід:** nums = [4,14,2]\n> **Вивід:** 6\n> **Пояснення:** У двійковому представленні 4 — це 0100, 14 — 1110, а 2 — 0010 (лише показано чотири біти, які мають відношення до цього випадку).\n> Відповідь буде:\n> HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n\n\n### Приклад 2:\n> **Ввід:** nums = [4,14,4]\n> **Вивід:** 4\n\n### Обмеження:\n* |{|1 <= nums.length <= 10^4^|}|\n* |{|0 <= nums[i] <= 10^9^|}|\n* Відповідь для заданого вхідного параметра вміщуватиметься в **32-розрядне** ціле число.\n\nЦю реалізацію було взято з Solutions. За час виконання `O(32 * N)`.\nПрипустимо, у нас є 5 чисел (у представленні за основою 2)\n\n1 1\n0 0\n0 0\n1 0\n1 0\n\nзамість того, щоб намагатися знайти відстань Хеммінга для кожного числа зі складністю O(N^2^), ми можемо знайти різницю стовпець за стовпцем, для цього нам потрібно підрахувати кількість одиниць і нулів, а потім помножити ці показники, у прикладі вище \nдля першого стовпця ми маємо: 3 * 2 = 6 (3 одиниці та 2 нулі) \nдля другого стовпеця ми маємо: 4 * 1 = 4 (4 нулі та 1 одиниця) \nРАЗОМ буде 6 + 4 = 10\n\n```js\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\nconst totalHammingDistance = function(nums) {\n    let n = nums.length, ans = 0;\n    for(let bit = 0; bit < 32; bit++) {\n        let zeros = 0, ones = 0;\n        for(let i = 0; i < n; i++) {\n            ((nums[i] >> bit) & 1) ? ones++ : zeros++;\n        }\n        ans += zeros * ones;\n    }\n    return ans;\n};\n```"
        },
        {
            "date": "2023-10-13",
            "status": "problem",
            "title": "Counting Bits",
            "text": "Дано ціле число `n`, поверніть масив `ans` довжини `n + 1`, щоб для кожного `i` (`0 <= i <= n`), `ans[i]` *було **числом одиниць** у двійковому представленні `i`*.\n#cut\n### Приклад 1:\n> **Ввід:** n = 2\n> **Вивід:** [0,1,1]\n> **Пояснення:**\n> 0 --> 0\n> 1 --> 1\n> 2 --> 10\n\n### Приклад 2:\n> **Ввід:** n = 5\n> **Вивід:** [0,1,1,2,1,2]\n> **Пояснення:**\n> 0 --> 0\n> 1 --> 1\n> 2 --> 10\n> 3 --> 11\n> 4 --> 100\n> 5 --> 101\n\n### Обмеження:\n* |{|0 <= n <= 10^5^|}|\n\n### Подальші дії:\n* Знайти рішення з часом виконання `O(n log n)` дуже легко. Чи можете ви зробити це за лінійний час `O(n)` і, можливо, за один прохід?\n* Чи можете ви зробити це без будь-якої вбудованої функції (наприклад, `__builtin_popcount` у C++)?\n\nНаписав свою реалізацію з часом виконання `O(32 n)`. Зробив цикл від 0 до n, та на кожній ітерації підраховував кількість бітів. Але це не оптимальне рішення, а найбільш оптимальне подивився у Solutions. \nПропонують два підходи: динамічне програмування з бітовими маніпуляціями та динамічне програмування з зсувом (offset). У обох випадках використовуються попередні суми для прискорення знаходження наступної суми.\nКод реалізації динамічного програмування з бітовими маніпуляціями наведено нижче:\n```js\n/**\n * @param {number} n\n * @return {number[]}\n */\nvar countBits = function countBits(n) {\n    const ans = new Array(n + 1).fill(0);\n    for (let i = 1; i <= n; i++) {\n        ans[i] = ans[i >> 1] + (i & 1);\n    }\n    return ans;\n}\n```"
        }
        ,
        {
            "date": "2023-10-14",
            "status": "fail",
            "title": "Binary Watch",
            "text": "Двійковий годинник має 4 світлодіоди у верхній частині, які представляють години (0-11), і 6 світлодіодів у нижній частині, які представляють хвилини (0-59). Кожен світлодіод представляє нуль або одиницю з молодшим значущим бітом праворуч.\n#cut\n* Наприклад, наведений нижче двійковий годинник читає `\"4:51\"`.\n![Binary watch](https://assets.leetcode.com/uploads/2021/04/08/binarywatch.jpg =500x500)\nДано ціле число `turnedOn`, яке представляє кількість світлодіодів, які наразі увімкнено (не враховуючи PM), поверніть *всі можливі часи, які може відображати годинник*. Ви можете повернути відповідь у **будь-якому порядку**.\n\nГодина не повинна містити початковий нуль.\n* Наприклад, `\"01:00\"` недійсний. Має бути `\"1:00\"`.\n\nХвилина повинна складатися з двох цифр і може містити нуль на початку.\n* Наприклад, `\"10:2\"` недійсний. Має бути `\"10:02\"`.\n\n### Приклад 1:\n> **Ввід:** turnedOn = 1\n> **Вивід:** [\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]\n\n\n### Приклад 2:\n> **Ввід:** turnedOn = 9\n> **Вивід:** []\n\n### Обмеження:\n* `0 <= turnedOn <= 10`\n\nПодивився у Solutions. Найпополярніше рішення - bruteforce-перебір усіх можливих часів та перевірка на відповідність числу `turnedOn`.\n\n```js\n/**\n * @param {number} turnedOn\n * @return {string[]}\n */\nvar readBinaryWatch = function(num) {\n    const times = [];\n  for (let h = 0; h < 12; h++) {\n    for (let m = 0; m < 60; m++) {\n      const hOnes = h ? h.toString(2).match(/1/g).length : 0;\n      const mOnes = m ? m.toString(2).match(/1/g).length : 0;\n      if (hOnes + mOnes === num) {\n        times.push(`${h}:${m < 10 ? `0${m}` : m}`);\n      }\n    }\n  }\n  return times;\n};\n```\n"
        },
        {
            "date": "2023-10-15",
            "status": "successful",
            "title": "Array Prototype Last",
            "text": "Напишіть код, який покращує всі масиви, щоб ви могли викликати метод `array.last()` для будь-якого масиву, і він повертав останній елемент. Якщо в масиві немає елементів, він має повернути `-1`.\nВи можете припустити, що масив є результатом `JSON.parse`.\n#cut\n### Приклад 1:\n> **Ввід:** nums = [null, {}, 3]\n> **Вивід:** 3\n> **Пояснення:** Виклик nums.last() має повернути останній елемент: 3.\n\n### Приклад 2:\n> **Ввід:** nums = []\n> **Вивід:** -1\n> **Пояснення:** Оскільки елементів немає, повертаємо -1.\n\n### Обмеження:\n* `arr` — дійсний масив JSON\n* `0 <= arr.length <= 1000`\n\nУсередені методу last звертаємось до вказівника this та перевіряємо властивість length. Якщо воно дорівнює 0, то повертаємо -1, якщо ні - повертаємо останній елемент масиву (this.at(-1)).\n```js\n/**\n * @return {null|boolean|number|string|Array|Object}\n */\nArray.prototype.last = function() {\n    if (this.length === 0) return -1;\n    return this.at(-1);\n};\n```"
        },
        {
            "date": "2023-10-16",
            "status": "successful",
            "title": "Binary Number with Alternating Bits",
            "text": "Дано додатне ціле число, перевірте, чи має воно чергування бітів: а саме, чи два сусідніх біта завжди матимуть різні значення.\n#cut\n### Приклад 1:\n> **Ввід:** n = 5\n> **Вивід:** true\n> **Пояснення:** Двійкове представлення числа 5 таке: 101\n\n### Приклад 2:\n> **Ввід:** n = 7\n> **Вивід:** false\n> **Пояснення:** Двійкове представлення числа 7 таке: 111.\n\n### Приклад 3:\n> **Ввід:** n = 11\n> **Вивід:** false\n> **Пояснення:** Двійкове представлення числа 11 таке: 1011.\n\n### Обмеження:\n* |{|1 <= n <= 2^31^ - 1|}|\n\nНаписав свою реалізацію, де перевіряється кожний біт числа на чергування - кожен біт не має дорівнювати попередньому.\n```js\n/**\n * @param {number} n\n * @return {boolean}\n */\nvar hasAlternatingBits = function(n) {\n    const str = n.toString(2);\n    let bit = (str[0] === '0');\n    for (let i = 1; i < str.length; i++) {\n        bit = !bit;\n        if (str[i] == bit) return false;\n    }\n    return true;\n};\n```"
        },
        {
            "date": "2023-10-17",
            "status": "successful",
            "title": "Decode XORed Array",
            "text": "Існує **прихований** масив цілих чисел `arr`, який складається з `n` цілих невід’ємних чисел.\nЙого було закодовано в інший масив цілих чисел, `encoded` довжиною `n - 1`, так що `encoded[i] = arr[i] XOR arr[i + 1]`. Наприклад, якщо `arr = [1,0,2,1]`, то `encoded = [1,2,3]`.\nВам надається `encoded` масив. Вам також спочатку надається ціле число `first`, яке є першим елементом `arr`, тобто `arr[0]`.\nПоверніть вихідний масив `arr`. Можна довести, що відповідь існує і вона єдина.\n#cut\n### Приклад 1:\n> **Ввід:** encoded = [1,2,3], first = 1\n> **Вивід:** [1,0,2,1]\n> **Пояснення:** Якщо arr = [1,0,2,1], то first = 1 і encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]\n\n### Приклад 2:\n> **Ввід:** encoded = [6,2,7,3], first = 4\n> **Вивід:** [4,2,0,7,4]\n\n### Обмеження:\n* |{|2 <= n <= 10^4^|}|\n* |{|encoded.length == n - 1|}|\n* |{|0 <= encoded[i] <= 10^5^|}|\n* |{|0 <= first <= 10^5^|}|\n\nНаписав рішення, нічого іншого там не може бути. Число `first` ставиться на початку результуючого масиву. Кожен наступний елемент розраховується у проході по масиву `encoded` з початку. Кожен наступний елемент `arr` дорівнює поточному елементу `arr` складеному по модулю 2 (операція xor) з поточним елементом `encoded`. \n```js\n/**\n * @param {number[]} encoded\n * @param {number} first\n * @return {number[]}\n */\nvar decode = function(encoded, first) {\n    const arr = new Array(encoded.length + 1);\n    arr[0] = first;\n    for (let i = 0; i < encoded.length; i++) {\n        arr[i + 1] = arr[i] ^ encoded[i];\n    }  \n    return arr;\n};\n```"
        },
        {
            "date": "2023-10-18",
            "status": "fail",
            "title": "Find The Original Array of Prefix Xor",
            "text": "Вам надається **цілочисельний** масив `pref` розміром `n`. Знайдіть і поверніть масив `arr` розміру `n`, який задовольняє:\n* `pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]`.\n\nЗауважте, що `^` позначає операцію **порозрядного** `xor`.\nМожна довести, що відповідь **унікальна**.\n#cut\n### Приклад 1:\n> **Ввід:** pref = [5,2,0,3,1]\n> **Вивід:** [5,7,2,3,2]\n> **Пояснення:** З масиву [5,7,2,3,2] ми маємо наступне:\n> - pref[0] = 5.\n> - pref[1] = 5 ^ 7 = 2.\n> - pref[2] = 5 ^ 7 ^ 2 = 0.\n> - pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.\n> - pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\n\n### Приклад 2:\n> **Ввід:** pref = [13]\n> **Вивід:** [13]\n> **Пояснення:** Маємо pref[0] = arr[0] = 13.\n\n### Обмеження:\n* |{|1 <= pref.length <= 10^5^|}|\n* |{|0 <= pref[i] <= 10^6^|}|\n\nРішення взяв з Editorial, бо моє вийшло, але не оптимізоване. Можна створити новий масив, а можна розкодувати 'на місці' і зменшити використання простору. Нульовий елемент масиву `pref` залишається бе змін.  Робиться один прохід по масиву `pref` з початку. Кожен поточний елемент на місці складається за модулем 2 з попереднім елементом. Після проходу масив `pref` повертається.\n```js\n/**\n * @param {number[]} pref\n * @return {number[]}\n */\nvar findArray = function(pref) {\n    const n = pref.length;\n\n    for (let i = n - 1; i > 0; i--) {\n        pref[i] = pref[i - 1] ^ pref[i];\n    }\n    return pref;\n};\n```\n"
        },
        {
            "date": "2023-10-19",
            "status": "successful",
            "title": "Counter",
            "text": "Дано ціле число `n`, поверніть функцію `counter`. Ця функція `counter` спочатку повертає `n`, а потім повертає на `1` більше попереднього значення під час кожного наступного виклику (`n`, `n + 1`, `n + 2` тощо).\n#cut\n### Приклад 1:\n> **Ввід:** \n> n = 10 \n> [\"call\",\"call\",\"call\"]\n> **Вивід:** [10,11,12]\n> **Пояснення:**\n> counter() = 10 // Під час першого виклику counter() повертається n\n> counter() = 11 // Повертає на 1 більше, ніж попереднього разу.\n> counter() = 12 // Повертає на 1 більше, ніж попереднього разу.\n\n### Приклад 2:\n> **Ввід:** \n> n = -2\n> [\"call\",\"call\",\"call\",\"call\",\"call\"]\n> **Вивід:** [-2,-1,0,1,2]\n> **Пояснення:** counter() спочатку повертає -2. Потім збільшується після кожного наступного виклику.\n\n### Обмеження:\n* `-1000 <= n <= 1000`\n* `0 <= calls.length <= 1000`\n* `calls[i] === \"call\"`\n\nЦе завдання легке. Усього на всього використовується замикання. Коли counter створюється, змінна count ініціується. Потім коли йде виклик counter вона кожного разу повертається та інкрементується. Змінна count не знищується, тому що на неє зсилається функція counter().\n```js\n/**\n * @param {number} n\n * @return {Function} counter\n */\nvar createCounter = function(n) {\n    let count = n\n    return () => count++\n};\n```\n"
        },
        {
            "date": "2023-10-20",
            "status": "successful",
            "title": "Counter II",
            "text": "Напишіть функцію `createCounter`. Вона має приймати початкове ціле число `init`, а повертати об’єкт із трьома функціями. \nЦі три функції:\n* `increment()` збільшує поточне значення на 1, а потім повертає його.\n* `decrement()` зменшує поточне значення на 1, а потім повертає його.\n* `reset()` встановлює поточне значення init, а потім повертає його.\n\n#cut\n### Приклад 1:\n> **Ввід:** init = 5, calls = [\"increment\",\"reset\",\"decrement\"]\n> **Вивід:** [6,5,4]\n> **Пояснення:**\n> const counter = createCounter(5);\n> counter.increment(); // 6\n> counter.reset(); // 5\n> counter.decrement(); // 4\n\n### Приклад 2:\n> **Ввід:** init = 0, calls = [\"increment\",\"increment\",\"decrement\",\"reset\",\"reset\"]\n> **Вивід:** [1,2,1,0,0]\n> **Пояснення:** \n> const counter = createCounter(0);\n> counter.increment(); // 1\n> counter.increment(); // 2\n> counter.decrement(); // 1\n> counter.reset(); // 0\n> counter.reset(); // 0\n\n### Обмеження:\n* `-1000 <= init <= 1000`\n* `0 <= calls.length <= 1000`\n* `calls[i]` є одним з \"increment\", \"decrement\" або \"reset\"\n\n\nЗавдання насправді легке. Треба повернути об'єкт з трьома вказівниками на функції `increment`, `decrement` та `reset`. Для збереження внутрішнього стану  лічильника `counter` використовується внутрішня змінна `counter` функції `createCounter`. Коли далі в коді буде виклик `counter.increment()`, то стан лічильника буде взятий з лексичного оточення функції `increment()`, а саме функції `createCounter`. \n\n```js\n/**\n * @param {integer} init\n * @return { increment: Function, decrement: Function, reset: Function }\n */\nvar createCounter = function(init) {\n    let counter = init\n    return {\n        increment: () => ++counter,\n        decrement: () => --counter,\n        reset: () => counter = init\n    }\n};\n```"
        },
        {
            "date": "2023-10-21",
            "status": "successful",
            "title": "Function Composition",
            "text": "Дано масив функцій |{|[f~1~, f~2~, f~3~, ..., f~n~]|}|, поверніть нову функцію `fn`, яка є **функціональною композицією** масиву функцій.\n**Композиція функцій** `[f(x), g(x), h(x)]` є `fn(x) = f(g(h(x))))`.\n**Композицією функцій** порожнього списку функцій є **функція тотожності** `f(x) = x`.\nВи можете припустити, що кожна функція в масиві приймає одне ціле число як вхід і повертає одне ціле число як вихід.\n#cut\n### Приклад 1:\n> **Ввід:** functions = [x => x + 1, x => x * x, x => 2 * x], x = 4\n> **Вивід:** 65\n> **Пояснення:**\n> Обчислення справа наліво ...\n> Починаючи з x = 4.\n> 2 * (4) = 8\n> (8) * (8) = 64\n> (64) + 1 = 65\n\n### Приклад 2:\n> **Ввід:** functions = [x => 10 * x, x => 10 * x, x => 10 * x], x = 1\n> **Вивід:** 1000\n> **Пояснення:**\n> Обчислення справа наліво ...\n> 10 * (1) = 10\n> 10 * (10) = 100\n> 10 * (100) = 1000\n\n### Приклад 3:\n> **Ввід:** functions = [], x = 42\n> **Вивід:** 42\n> **Пояснення:**\n> Композиція нульових функцій є функцією тотожності\n\n### Обмеження:\n* `-1000 <= x <= 1000`\n* `0 <= functions.length <= 1000`\n* усі функції приймають і повертають одне ціле число\n\nПослідовно, але починаючи з кінця, проходимо по масиву `functions` та викликаємо кожну на змінній `x`, у цю змінну одразу записуємо результат. Після проходу над `x` будуть виконані всі `functions`, тобто ця функція ідентична композиції функцій.\n```js\n/**\n * @param {Function[]} functions\n * @return {Function}\n */\nvar compose = function(functions) {\n    \n    return function(x) {\n\n        for (let i = functions.length - 1; i >= 0; i--) {\n            x = functions[i](x);\n        } \n        return x;\n    }\n};\n```"
        },
        {
            "date": "2023-10-22",
            "status": "fail",
            "title": "Memoize",
            "text": "Дано функцію `fn`, повернути **мемоізовану** версію цієї функції.\n**Мемоізована** функція – це функція, яка ніколи не буде викликана двічі з однаковими вхідними даними. Натомість вона поверне кешоване значення.\nВи можете припустити, що існує **3** можливі функції введення: `sum`, `fib` і `factorial`.\n* `sum` приймає два цілі числа `a` і `b` і повертає `a + b`.\n* `fib` приймає єдине ціле число `n` і повертає `1`, якщо `n <= 1`, або `fib(n - 1) + fib(n - 2)` в іншому випадку.\n* `factorial` приймає єдине ціле число `n` і повертає `1`, якщо `n <= 1`, або `factorial(n - 1) * n` в іншому випадку.\n\n#cut\n### Приклад 1:\n> **Ввід:** \n> fnName = \"sum\"\n> actions = [\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\n> values = [[2,2],[2,2],[],[1,2],[]]\n> **Вивід:** [4,4,1,3,2]\n> **Пояснення:** \n> const sum = (a, b) => a + b;\n> const memoizedSum = memoize(sum);\n> memoizedSum(2, 2); // \"call\" - повертає 4. sum() було викликано, оскільки (2, 2) раніше не було.\n> memoizedSum(2, 2); // \"call\" - повертає 4. Однак sum() не було викликано, оскільки ті самі вхідні дані бачили раніше. \n> // \"getCallCount\" - загальна кількість викликів: 1\n> // \"getCallCount\" - загальна кількість викликів: 1\n> memoizedSum(1, 2); // \"call\" - повертає 3. sum() було викликано, оскільки (1, 2) раніше не було.\n> // \"getCallCount\" - загальна кількість викликів: 2\n\n### Приклад 2:\n> **Ввід:** \n> fnName = \"factorial\"\n> actions = [\"call\",\"call\",\"call\",\"getCallCount\",\"call\",\"getCallCount\"]\n> values = [[2],[3],[2],[],[3],[]]\n> **Вивід:** [2,6,2,2,6,2]\n> **Пояснення:** \n> const factorial = (n) => (n <= 1) ? 1 : (n * factorial(n - 1));\n> const memoFactorial = memoize(factorial);\n> memoFactorial(2); // \"call\" - повертає 2.\n> memoFactorial(3); // \"call\" - повертає 6.\n> memoFactorial(2); // \"call\" - повертає 2. Однак factorial не було викликано, оскільки 2 було помічено раніше.\n> // \"getCallCount\" - загальна кількість викликів: 2\n> memoFactorial(3); // \"call\" - повертає 6. Однак factorial не було викликано, оскільки 3 було помічено раніше.\n> // \"getCallCount\" - загальна кількість викликів: 2\n\n### Приклад 3:\n> **Ввід:** \n> fnName = \"fib\"\n> actions = [\"call\",\"getCallCount\"]\n> values = [[5],[]]\n> **Вивід:** [8,1]\n> **Пояснення:** \n> fib(5) = 8 // \"call\"\n> // \"getCallCount\" - загальна кількість викликів: 1\n\n### Обмеження:\n* |{|0 <= a, b <= 10^5^|}|\n* `1 <= n <= 10`\n* |{|0 <= actions.length <= 10^5^|}|\n* `actions.length === values.length`\n* `actions[i]` є одним з \"call\" та \"getCallCount\"\n* `fnName` є одним  з \"sum\", \"factorial\" та \"fib\"\n\nРішення подивився у Solutions. Функція `memoize` приймає у якості аргумента функцію, а повертає \"мемоізовану\" функцію. Нова функція зберегає кеш обчисленних відповідей у об'єкті типу Map за ключем, що складається з текстового представлення вхідних аргументів. Цей кеш зберігається у замиканні (внутрішня змінна функції `memoize`).\n```js\n/**\n * @param {Function} fn\n * @return {Function}\n */\nfunction memoize(fn) {\n    let cache = new Map();\n    return (...args) => {\n        const key = JSON.stringify(args);\n        return cache.has(key) ? cache.get(key) : cache.set(key, fn(...args)).get(key);\n    }\n}\n```"
        }
    ]
}