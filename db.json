{
    "posts": [
        {
            "date": "12.07.2023",
            "type": "successful",
            "title": "Minimum Depth of Binary Tree",
            "text": "Пошук мінімальної глибини бінарного дерева. Обхід по дереву можливий за алгоритмами DFS (Depth-first search) та BFS (Breadth-first search). Мінімальна глибина бінарного дерева це відстань від кореня до найближчого листка (це вузел без нащадків). У цій проблемі, з огляду на швідкість пошуку рішення, краще використати BFS.",
            "textUnderSpoiler": ""
        },
        {
            "date": "13.07.2023",
            "type": "fail",
            "title": "Check if Object Instance of Class",
            "text": "Напишіть функцію, яка перевіряє, чи дане значення є екземпляром даного класу або суперкласу. Для цієї проблеми об’єкт вважається екземпляром даного класу, якщо цей об’єкт має доступ до методів цього класу. <br/> Цікава проблема, вбудованого instanceof недостатньо. В алгоритмі перевірки використовується конструктор об'єкта.",
            "textUnderSpoiler": ""
        },
        {
            "date": "14.07.2023",
            "type": "successful",
            "title": "Longest Arithmetic Subsequence of Given Difference",
            "text": "Не одразу зрозуміло що саме треба шукати. Це не підрядок. Підпослідовність це як окремі елементи з похідного масиву, які тільки у тому самому порядку йдуть, та відповідають заданим умовам.<br/> У цій проблемі це - різниця - ціле число на яке зростають/зменшуються числа у підпослідовності. Треба повернути довжину найбільшої підпослідовності.",
            "textUnderSpoiler": ""
        },
        {
            "date": "15.07.2023",
            "type": "successful",
            "title": "All Nodes Distance K in Binary Tree",
            "text": "Маючи корінь бінарного дерева, значення цільового вузла та ціле число k, поверніть масив значень усіх вузлів, які мають відстань k від цільового вузла.",
            "textUnderSpoiler": "Цікава проблема, яку не зовсім зрозуміло як вирішувати. Є найпростіший спосіб з додаванням зворотних зв'язків з батьківським елементом для зворотнього руху по дереву, але цей підхід вважається поганою практикою. Рекомендують робити всеспрямований граф і вже з ним працювати. Почати з target-елемента рекурсивно викликати BFS з передаванням глибини на 1 менше. І так доки глибина не дійде до нуля. Знайдені елементи заносятся до масиву результата."
        },
        {
            "date": "16.07.2023",
            "type": "successful",
            "title": "Binary Tree Inorder Traversal",
            "text": "Даний корінь бінарного дерева, поверніть упорядкований обхід значень його вузлів. ",
            "textUnderSpoiler": "Ця проблема легкого рівня. Більш детально розглядаю варіанти обходу дерева. <br/> Існують такі варіанти: <br/>&nbsp - прямий порядок; <br/>&nbsp - зворотній порядок; <br/>&nbsp - симетричний порядок;             <br/>&nbsp - зворотньо-симетричний порядок. <br/> Варіант обходу залежить від послідовності виклику лівого та правого піддерева, а також звернення до батьківського елементу. "
        },
        {
            "date": "17.07.2023",
            "type": "successful",
            "title": "Add Two Numbers II",
            "text": "У цьому завданні надано два непорожніх пов’язаних списка, що представляють два цілі невід’ємні числа. Найстарша цифра йде першою, і кожен з їхніх вузлів містить одну цифру. Додайте два числа та поверніть суму у вигляді зв’язаного списку.",
            "textUnderSpoiler": "Треба порахувати суму ніби у стовпчик, але кожне число то одно-спрямований список (не масив). Завдання вирішено з використанням допоміжних стеків для обох списків, тому що обхід та формування суми треба розпочинати з наймолодших цифр."
        },
        {
            "date": "18.07.2023",
            "type": "successful",
            "title": "LRU Cache",
            "text": "Створіть структуру даних, яка відповідає характеристикам кешу, що останнім часом використовувався (LRU).",
            "textUnderSpoiler": "Тут ідея в тому, що кеш має якийсь ліміт за розміром, тому спочатку він наповнюється елементами, потім треба, перед додаванням нового елементу, знайти який з попередніх був довше за усіх непотрібний, та видалити його. <br/> У реалізації алгоритму використаний об'єкт Map (асоціативний масив). Кожного разу, коли йде звернення до кешу, послідовність елементів змінюється. Той елемент, до якого був доступ чи новий доданий переміщується у кінець кешу. Коли кеш набуває лімітованого розміру, тоді додатково на початку кешу буде видалятися 'найстаріший' елемент, коли треба додати новий елемент."
        },
        {
            "date": "19.07.2023",
            "type": "successful",
            "title": "Non-overlapping Intervals",
            "text": "Інтервали, що не перекриваються. Дано масив інтервалів intervals, де intervals[i] = [start_i, end_i], поверніть мінімальну кількість інтервалів, які потрібно видалити, щоб решта інтервалів не перекривалася.",
            "textUnderSpoiler": "Проблема medium-рівня, яку одразу і не зрозуміло як вирішувати. Подивився editorial. Це відома проблема інтервального планування, яка дуже часто зустрічається у програмуванні та добре описана. <br/>      Проблема максимізації інтервального планування (ISMP) полягає в тому, щоб знайти найбільший сумісний набір, тобто набір непересічних інтервалів максимального розміру. Мета тут полягає в тому, щоб виконати якомога більше завдань, тобто максимізувати пропускну здатність. Це еквівалентно знаходженню максимального незалежного набору в інтервальному графі.<br/>                            Алгоритм який запропонований досить простий. Інтервали спочатку сортуються по часу закінчення за зростанням. Потім у циклі шукається найкоротші інтервали, які ідуть без перекривання, усі інші які перекриваються, рахуються та їх сума повертаються у вигляді відповіді."
        },
        {
            "date": "20.07.2023",
            "type": "successful",
            "title": "Asteroid Collision",
            "text": "Зіткнення астероїдів. Нам надано масив астероїдів цілих чисел, що представляють астероїди в рядку. Для кожного астероїда абсолютне значення представляє його розмір, а знак — його напрямок (позитивне означає праворуч, негативне значення — ліворуч). ",
            "textUnderSpoiler": "Кожен астероїд рухається з однаковою швидкістю. Дізнайтеся стан астероїдів після всіх зіткнень. Якщо два астероїди зустрінуться, менший з них вибухне. Якщо обидва мають однаковий розмір, обидва вибухнуть. Два астероїди, що рухаються в одному напрямку, ніколи не зустрінуться.  <br>       Цікава проблема. Я не став нічого вигадувати і подивися editorial. Дуже хитрий алгоритм. Рішення полягає у роботі з допоміжним масивом або стеком, до якого заносяться ті астероїди, що слід обробити. Далі вони послідовно порівнюються з іншими астероїдами та визначається чи залишится він у стеку або він 'вибухне'. Кожен астероїд порівнюється з кожним іншим рівно один раз. Після цього результуючий стек чи масив вважається готовим."
        },
        {
            "date": "21.07.2023",
            "type": "problem",
            "title": "Number of Longest Increasing Subsequence",
            "text": "Кількість найдовших зростаючих підпослідовностей.<br/>               Перш ніж спробувати вирішити цю задачу, дуже рекомендують, спочатку розв’язати найдовшу зростаючу підпослідовність, до якої ця задача є продовженням. Але я з нею ще не стикався. Рішення я подивився в editorial, так і не зрозумів його, та просто переписав наведений код у JS."
        },
        {
            "date": "22.07.2023",
            "type": "successful",
            "title": "Find the Index of the First Occurrence in a String",
            "text": "Знайдти індекс першого входження в рядок.<br/> Дано два рядки needle і haystack, поверніть індекс першого входження needle у haystack або -1, якщо needle не є частиною haystack.",
            "textUnderSpoiler": "Звичайно у JS є метод string.prototype.indexOf(subStr).Але схоже треба зробити свою реалізацію. Я написав, потім ще трохи переробив алгоритм, але мабуть не зовсім те що треба.                                    Орієнтуватися треба на такі оптимальні алгоритми:                                                                     <br/> &nbsp - <a class='font-bold underline' href='http://en.wikipedia.org/wiki/Boyer-Moore_string_search_algorithm'> Boyer-Moore</a> uses a bad character table with a good suffix table.                                                   <br/> &nbsp - <a class='font-bold underline' href='http://en.wikipedia.org/wiki/Boyer-Moore-Horspool_algorithm'> Boyer-Moore-Horspool</a> uses a bad character table.                                                                   <br/> &nbsp - <a class='font-bold underline' href='http://en.wikipedia.org/wiki/Knuth-Morris-Pratt_algorithm'> Knuth-Morris-Pratt</a> uses a partial match table.                                                                     <br/> &nbsp - <a class='font-bold underline' href='http://en.wikipedia.org/wiki/Rabin-Karp_string_search_algorithm'> Rabin-Karp</a> uses running hashes                                                                                    <br/>Спробував реалізувати Boyer-Moore-Horspool, але схоже що він краще працює на C ніж yf JS."
        },
        {
            "date": "24.07.2023",
            "type": "successful",
            "title": "Merge Two Sorted Lists",
            "text": "Вам надано заголовки двох відсортованих пов’язаних списків list1 і list2. Об’єднайте два списки в один відсортований список. Список має бути створений шляхом з’єднання вузлів перших двох списків. Поверніть заголовок об’єднаного зв’язаного списку.",
            "textUnderSpoiler": "Є реалізація, але дуже повільна і пам'ять жере. Треба зробити якось без new. Подивився як роблять інші - різні підходи є. Мені сподобався варіант де просто з двох списків формується один результуючий, при цьому нові вузли не створюються."
        },
        {
            "date": "25.07.2023",
            "type": "successful",
            "title": "Merge k Sorted Lists",
            "text": "Вам надано масив із k зв’язаних списків, кожен зв’язаний список відсортований у порядку зростання. Об’єднайте всі зв’язані списки в один відсортований зв’язаний список і поверніть його. Проблема рівня hard",
            "textUnderSpoiler": "Спробував зробити для k списків приблизно за учорашнім алгоритмом, але попередньо сортуючи списки за значенням val перших елементів. Працює, але ну дуже повільно. Дуже багато разів іде сортування. Подивився що у інших, який там самий швидкий алгоритм. Виявилося, що можна було всі елементи списків запушити у масив (елемент масива це об'єкт з полями val та next). Потім цей весь масив один раз сортується за значеннями val. Потім цей масив перетворюється у список. При цьому правильно виставляються поля next у кожного елемента з масиву. У фіналі оформлюється tail, та повертається нульовий елемент масиву (як head)."
        },
        {
            "date": "26.07.2023",
            "type": "successful",
            "title": "Merge Sorted Array",
            "text": "Задача об'єднати два неубиваючі масиви розміром m+n та n. У першому масиві останні n елементів заповнені 0.",
            "textUnderSpoiler": "Задачу спочатку вирішив як найпростіше - другий скопіював у кінець першого, а потім відсортував. Але це не оптимальний підхід. <br/> Щоб складність була O(m + n) треба піти іншим шляхом. Почати с кінця першого масива формувати одразу відсортований, шляхом порівняння елементів з першого та другого масивів. Таким шляхом за один прохід по масиву буде сформовано результуючий неубиваючий масив."
        },
        {
            "date": "27.07.2023",
            "type": "problem",
            "title": "Maximum Running Time of N Computers",
            "text": "Максимальний час роботи N комп’ютерів - задача на разрахунок максимального часу n ноутбуків від m (m >= n) батарей акумуляторів. Треба прорахувати на скільки вистачить усіх батарей якщо їх швидко замінювати у комп'ютерах. Ввважається що час заміни невідчутно малий.",
            "textUnderSpoiler": "Задача цікава, особливо від час блекаутів) Я початку спробував просто вирахувати загальну кількість годин роботи (заряду) зі всіх батарей, та розділити на кількість комп'бтерів, результат окриглив до меншого цілого. Але тест кейси деякі не проходили. Стало ясно що не завжди можливо замінити батарею, тому треба якось перевіряти чи можнаа так розставити батареї, щоб усі компи одночасно працювали. Подивився editorial, там якій не дуже зрозумілі підходи та алгоритми, повторити які не вдалося, бо там використовувся тип long, а у мене в JS викидало помилку. <br/> Але коли я почав дивитися просто чиїсь готові рішення мене вразило, на скільки просто ця задача розв'язувалася. Дуже просте рішеня полягало в тому, що спочатку масив з батареями сортували, потім у циклі робили перевірку, якщо ємність одної з батареї перевищувала середню ємність на один комп'ютер, то таку батерею відкидали (із масиву) і комп'ютер в якому вона буде працювати теж, та перераховували середню ємність на компьютер. І так до тих пір, поки  ємність останньої батареї не стає рівною або менше за перераховану середню ємність. Саме її і слід повернути як результат."
        },
        {
            "date": "28.07.2023",
            "type": "fail",
            "title": "Predict the Winner",
            "text": "Вам надано цілочисельний масив nums. Два гравці грають у гру з цим масивом: гравець 1 і гравець 2. Гравець 1 і гравець 2 по черзі, причому гравець 1 починає першим. Обидва гравці починають гру з результатом 0. Кожного ходу гравець бере одне з чисел з обох кінців масиву (тобто nums[0] або nums[nums.length - 1]), що зменшує розмір масиву на 1. Гравець додає вибране число до свого рахунку. ",
            "textUnderSpoiler": "Гра закінчується, коли в масиві більше немає елементів. Поверніть true, якщо Гравець 1 може виграти гру. Якщо бали обох гравців однакові, тоді гравець 1 все ще є переможцем, і ви також повинні повернути true. Ви можете припустити, що обидва гравці грають оптимально.<br/> Завдання medium рівня. І я не знав як робити. Подивився в editorial. Перші два підходи спробував запустити. Другий більш оптимальний, тому що часткові результати обчислень зберігаються у кеші. Сама ідея у тому, що рекурсивно викликається функцція maxDiff(), яка обчислює скільки балів отримає гравець на рахунок. При цьому звісно 'гравець точно розраховує скількі балів він отримує в кінці гри, та робить тільки вигідний для нього хід'. Отже maxDiff отримує два аргументи left та right - це індекси з початку та кінця масиву. А у середені функції обчислюється обидва варіанти ходу та знову викликається для обох варіантів maxDiff. Рекурсія припиняється коли масив з балами звужується до одного числа. Але схоже, що цей алгоритм я так і не зрозумів. Логіка мені до кінця не зрозуміла."
        },
        {
            "date": "29.07.2023",
            "type": "problem",
            "title": "Maximum Product Subarray",
            "text": "Максимальний підмасив добутку. Дано цілочисельний масив nums, знайти підмасив із найбільшим добутком і повернути добуток. Тестові приклади генеруються таким чином, що відповідь поміщається в 32-розрядне ціле число.",
            "textUnderSpoiler": "Цікава задача, я її вирішив і знову геть не оптимально. Подивився, що люди пропонують. І той варіант мені сподобався. За один прохід (O(n)) результат обчислюється. Треба було пройти по масиву, обчислюючи поточний максимум та поточний мінімум (для від'ємних результатів). Вони також використовуються для обчислення самих себе але при наступній ітерації. Якщо поточний максимум перевищить загальний результат, то загальний результат переприсвоюється."
        },
        {
            "date": "31.07.2023",
            "type": "successful",
            "title": "Add Two Numbers",
            "text": "Вам надано два непорожніх пов’язаних списку, що представляють два цілі невід’ємні числа. Цифри зберігаються у зворотному порядку, і кожен їх вузол містить одну цифру. Додайте два числа та поверніть суму у вигляді зв’язаного списку. Ви можете припустити, що два числа не містять жодного початкового нуля, окрім самого числа 0.",
            "textUnderSpoiler": "Ця задача подібна до Add Two Nunbers II, але в чомусь навіть простіша. Проходимо по двом спискам одночасно та формуємо третій - результат. Після того як досягли кінця обох списків, треба звернути увагу на перенос. Повертаємо завчасно збережений вказівник на початок результуючого списку."
        },
        {
            "date": "02.08.2023",
            "type": "successful",
            "title": "Plus One",
            "text": "Вам надано велике ціле число, представлене у вигляді цілого масиву цифр, де кожна цифра[i] є i-ю цифрою цілого числа. Цифри впорядковані від найбільш значущих до найменш значущих у порядку зліва направо. Велике ціле число не містить початкових нулів.",
            "textUnderSpoiler": "Збільште велике ціле число на одиницю та поверніть отриманий масив цифр.<br/> Приклади:<br/>Input: digits = [1,2,3]<br/>Output: [1,2,4]<br/>Input: digits = [4,3,2,1]<br/>Output: [4,3,2,2]<br/>Input: digits = [9]<br/>Output: [1,0]Обмеження:<br/>&nbsp - 1 <= digits.length <= 100<br/>&nbsp - 0 <= digits[i] <= 9<br/>&nbsp - digits не містить початкових нулів.<br/>Пропоную таке рішення. Ідемо з кінця масиву. Якщо там спочатку йде 9 або кілька 9-ок підряд, то їх перезаписуємо на 0. Коли дійдемо до першої цифри яка не дорівнює 9, то просто додамо до цього числа 1. А якщо там взагалі всі 9-ки у вхідному масиві, то треба додати елемент з 1 напочатку масиву."
        },
        {
            "date": "03.08.2023",
            "type": "successful",
            "title": "Add Binary",
            "text": "Дано два двійкові рядки a і b, повернути їх суму як двійковий рядок.<br/>Приклади:<br/>    Input: a = '11', b = '1'<br/>Output: '100'<br/>Input: a = '1010', b = '1011'<br/>Output: '10101'",
            "textUnderSpoiler": "Обмеження:<br/>&nbsp - 1 <= a.length, b.length <= 10^4<br/>&nbsp - a і b складаються лише з символів «0» або «1».<br/>&nbsp - Кожен рядок не містить початкових нулів, за винятком самого нуля.<br/>    Моє рішення просте. Ідемо з кінця одночасно по обом рядкам та знаходимо суму по кожному розряду. Також прораховується перенос. Якщо обидва рядки скінчились, а у переносі є одиниця, то вона записується у найвищий розряд."
        },
        {
            "date": "04.08.2023",
            "type": "problem",
            "title": "Path Crossing",
            "text": "Дано рядковий path, де path[i] = 'N', 'S', 'E' або 'W', кожен з яких представляє переміщення на одну одиницю на північ, південь, схід або захід відповідно. Ви починаєте з початку (0, 0) на двовимірній площині та йдете по шляху, визначеному path. Поверніть true, якщо шлях перетинає сам себе в будь-якій точці, тобто якщо в будь-який час ви перебуваєте в місці, яке відвідали раніше. В іншому випадку поверніть false.",
            "textUnderSpoiler": "Проблема Easy-рівня. Якось не дуже просто з двовимірними масивами у JS, тому зробив менш оптимально по тайм комплесіті, але більш оптимально за меморі комплексіті. <br/>           Створюю сет, та додаю в нього коорддинати у вигляді рядка x+','+y на кожному кроці. Координати x та y змінюються в залежності від символа у path[i]. Перед кожним додаванням, перевіряю чи є такі координати у сеті (тобто чи була вже відвідана ця точка.)"
        },
        {
            "date": "05.08.2023",
            "type": "fail",
            "title": "Word Break",
            "text": "Дано рядок s і словник рядків wordDict, поверніть true, якщо s можна сегментувати на розділену пробілами послідовність одного або кількох словникових слів. Зауважте, що одне й те саме слово в словнику може використовуватися кілька разів у сегментації.",
            "textUnderSpoiler": "Подивився в editorial. Перший підхід - BFS пошук вширш. Тут будується дерево варіантів як можна скласти строку s з тих слів, що є в wordDict. Переписав наведену реалізацію з Java у JavaScript. Для алгоритму треба було структуру даних типу черга (queue), реалізацію такого класу узяв з інтернету. Непогане рішення вийшло, але часова складність алгоритму O(n^3 + m*k).<br/> Існують більш оптимальні методи рішення цієї задачі."
        },
        {
            "date": "06.08.2023",
            "type": "successful",
            "title": "Reverse Integer",
            "text": "Дано 32-розрядне ціле число x зі знаком, повернути x зі реверсованими цифрами. Якщо реверсування x призводить до того, що значення виходить за межі 32-розрядного цілого діапазону зі знаком [-2^31, 2^31 - 1], поверніть 0. Припустімо, що середовище не дозволяє зберігати 64-розрядні цілі числа (зі знаком або без нього).",
            "textUnderSpoiler": "Так, у JS числа зберігаються у безпечному діапазоні ±(2^53 - 1), тому треба відстежувати виход із цих меж.<br/> Отож, спочатку беремо абсолютне значення, реверсуємо його, потім перевіряємо результат на перевищення дозволеного ліміту і на останок додаємо знак мінуса, якщо дане чило було від'ємним. Можна також зробити ланцюжок split-reverse-join. "
        },
        {
            "date": "08.08.2023",
            "type": "successful",
            "title": "Palindrome Number",
            "text": "Дано ціле число x, поверніть true, якщо x є паліндромом, і false в іншому випадку.",
            "textUnderSpoiler": "Це легка задача, вирішив шляхом конвертації у строку, знаходження середини та проходу у циклі з порівнянням з кінця та з початку.<br/>  У Solutions пропонують варіант без конвертації у строку, а замість цього просто реверсується х. Це роблять знаходженням залишку від поділу на 10, та подальшого поділу на 10 числа x у циклі. З залишків поділу, які кожного разу помножуються на 10, формується реверсоване число."
        },
        {
            "date": "09.08.2023",
            "type": "fail",
            "title": "Valid Number",
            "text": "Треба перевірити надану зміну s чи вона є валідним числом та повернути true або false. Задача hard-рівня, яку я не зміг самостійно вирішити. Подивився в solutions. Перше рішення, що я побачив, сподобалось, тому що сам хотів щось таке написати. ",
            "textUnderSpoiler": "Отже, для рішення цієї проблеми ми повинні скласти список можливих умов помилок та тоді перевірити кожний з них. <br/> Умови помилок:  <br/>&nbsp - Більш ніж один символ ('e'/'E'), або зустрічання 'e'/'E' коли число ще не зустрілося. <br/>&nbsp - Більш ніж один знак, або знак, який з'явлється після коми чи числа. Це скасовується після проходження 'e'/'E'. <br/>&nbsp - Більш ніж одна кома або кома, яка з'являється після зустрічання 'e'/'E'. <br/>&nbsp - Зустрічання будь-яких інших нецифрових символів. <br/>&nbsp - Досягнення кінця s без активного числа.<br/>     Щоб було зручніше, ми можемо встановити прапорці для відстеження різних речей (num, exp, sign, dec). Ми будемо також пам'ятати скидати усі прапорці, окрім exp, коли ми зустрінемо 'e'/'E', оскільки ми починаємо новий цілочислений вираз.<br/> Також є варіант рішення у один рядок, але там використовується приведення типів. Можна наприклад s поділити на 1 та порівняти з s."
        },
        {
            "date": "10.08.2023",
            "type": "successful",
            "title": "Path Crossing",
            "text": "Дано рядковий шлях, де path[i] = 'N', 'S', 'E' або 'W', кожен з яких представляє переміщення на одну одиницю на північ, південь, схід або захід відповідно. Ви починаєте з початку координат (0, 0) на 2D площині та йдете по шляху, визначеному path. Поверніть true, якщо шлях перетинає сам себе в будь-якій точці, тобто якщо в будь-який час ви перебуваєте в місці, яке відвідали раніше. В іншому випадку поверніть false.",
            "textUnderSpoiler": "Обмеження: <br/>&nbsp - 1 <= path.length <= 10^4 <br/>&nbsp - path[i] is either 'N', 'S', 'E', or 'W'. <br/>  Вирішив, але мабуть це не дуже оптимальний по швидкості алгоритм. Кожний хід я записую у сет (у вигляді рядку 'x,y'). Перед записом, перевіряю, чи була вже ця точка відвідана. Якщо так - повертаємо false."
        },
        {
            "date": "11.08.2023",
            "type": "successful",
            "title": "Valid Parentheses",
            "text": "Дано рядок s, який містить лише символи '(', ')', '{', '}', '[' та ']', визначити, чи введений рядок дійсний. ",
            "textUnderSpoiler": "Вхідний рядок дійсний, якщо: відкриті дужки повинні бути закриті дужками того самого типу.  <br/>  Відкриті дужки повинні бути закриті в правильному порядку. Кожна закрита дужка має відповідну відкриту дужку такого ж типу. <br/>  Наприклад: <br/> Вхід: s = '()[]{}' <br/>   Вихід: true <br/> Вхід: s = '(]' <br/>  Вихід: false <br/> Обмеження: <br/>&nbsp - 1 <= s.length <= 10^4 <br/>&nbsp - s складається тільки з дужок '()[]{}'. <br/> Задача Easy-рівня. У циклі проходимо кожний символ. Якщо дужка відкривається, то кладемо її у стек. Якщо закривається, то дістаємо елемент зі стеку і порівнюємо: якщо дужка відповідна, то добре, ідемо далі, а якщо ні - повертаємо false. Якщо дійдемо до кінця строки, то треба перевірити чи пустий стек. Повертаємо true якщо пустий та false, якщо - ні."
        },
        {
            "date": "12.08.2023",
            "type": "successful",
            "title": "Generate Parentheses",
            "text": "Дано n пар дужок, напишіть функцію для генерування всіх комбінацій правильно сформованих дужок.",
            "textUnderSpoiler": "Наприклад: <br/> Вхід: n = 3 <br/> Вихід: ['((()))','(()())','(())()','()(())','()()()'] <br/> Обмеження: <br/>&nbsp - 1 <= n <= 8  <br/>  Так, задача не важка, вирішив самостійно. Ідея у тому, що кожен наступний символ це '(' або ')'. Тому можна рекурсивно одразу для двох випадків формувати наступний символ.  <br/>  Я написав функцію gen(str, n, parenthesesDepth), де str - строка що формується, n - кількість невідкритих дужок та parenthesesDepth - кількіть відкритих дужок. <br/>  Під час кожного виклику цієї функції, якщо це можливо, викликається знову gen з '(', та gen з ')'. Якщо лічильнтки невідкритих та закритих дужок обидва стануть рівними 0, то сфомована строка вноситься у масив результатів."
        },
        {
            "date": "13.08.2023",
            "type": "successful",
            "title": "Letter Combinations of a Phone Number",
            "text": "Дано рядок, що містить цифри від 2 до 9 включно, повертає всі можливі комбінації букв, які може представляти число. Поверніть відповідь у довільному порядку. Відображення цифр і літер (так само, як на кнопках телефону) подано нижче. Зауважте, що 1 не відповідає жодній букві.",
            "textUnderSpoiler": "Наприклад: <br/> Вхід: цифри = '23' <br/> Вихід: ['ad','ae','af','bd','be','bf','cd','ce','cf'] <br/> Обмеження: <br/>&nbsp - 0 <= digits.length <= 4 <br/>&nbsp - digits[i] is a digit in the range ['2', '9']. <br/>  Цю задачу вдалось вирішити самостійно. Спочатку складаємо таблицю відповідностей, де кожній цифрі відповідає масив букв. Потім рекурсивно генеруємо усі можливі послідовності. Беремо першу цифру, знаходимо відповідні букви і для кожної викликаємо рекусію з наступною цифрою. Коли послідовність цифр завершується рекурсія припиняється. а сформовані строки записуються до масиву результатів."
        },
        {
            "date": "14.08.2023",
            "type": "problem",
            "title": "Permutations",
            "text": "Дано масив nums різних цілих чисел, повернути всі можливі перестановки. Ви можете повернути відповідь у будь-якому порядку.",
            "textUnderSpoiler": "### Обмеження: \n* `1 <= nums.length <= 6` \n* `-10 <= nums[i] <= 10` \n* Усі цілі числа nums є унікальними. \n *** \n  Не зміг я сам вирішити цю задачу, дивися editorial. \n У алгоритмі використовується рекурсія. Ідея в тому, що наступний елемент послідовності може бути будь-яким елементом, окрім тих елементів, які вже використані в поточній послідовності. Кожен наступний елемент це результат наступного рекурсивного виклику. Коли всі елементи використані, результуюча послідовність записується до масиву результатів."
        },
        {
            "date": "15.08.2023",
            "type": "problem",
            "title": "Next Permutation",
            "text": "Дано масив цілих чисел `nums`, знайти наступну перестановку `nums`.Заміна має бути на місці та використовувати лише постійну додаткову пам’ять.",
            "textUnderSpoiler": "Перестановка масиву цілих чисел — це розміщення його членів у послідовності або лінійному порядку. \n Наприклад, для `arr = [1,2,3]` наступні перестановки `arr: [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1].` \n Наступна перестановка масиву цілих чисел є наступною лексикографічно більшою перестановкою його цілого числа. Більш формально, якщо всі перестановки масиву відсортовані в одному контейнері відповідно до їх лексикографічного порядку, то наступна перестановка цього масиву є перестановкою, яка слідує за ним у відсортованому контейнері. Якщо таке розташування неможливе, масив потрібно перевпорядкувати в найнижчому можливому порядку (тобто відсортувати в порядку зростання). \n Наприклад, наступною перестановкою `arr = [1,2,3] є [1,3,2]`. \n Аналогічно, наступна перестановка `arr = [2,3,1]` є `[3,1,2]`.  \n Тоді як наступною перестановкою `arr = [3,2,1]` є `[1,2,3]`, оскільки `[3,2,1]` не має лексикографічного більшого перегрупування. \n *** \n> Щоб вирішити цю задачу, довелось підгледіти статтю на вікіпедії про перестановки. В editorial той самий підхід. За їхнім алгоритмом написав функцію, яка робить наступну перестановку у лексикографічному порядку.  \n Алгоритм дій: \n 1. Знайти найбільший індекс `k` такий, що `a[k] < a[k + 1]`. Якщо такого індексу не існує, перестановка є останньою (а тому послідовність треба повністтю обернути).  \n 2. Знайти найбільший індекс `l`, більший за `k`, такий, що `a[k] < a[l]`. \n 3. Замінити значення `a[k]` на значення `a[l]`.  \n 4. Обернути послідовність від `a[k + 1]` до кінцевого елемента `a[n]` включно."
        },
        {
            "date": "16.08.2023",
            "type": "problem",
            "title": "Remove Element",
            "text": "Дано цілочисельний масив `nums` і ціле число `val`, видалити всі входження `val` у `nums` на місці. Порядок елементів може бути змінений. ",
            "textUnderSpoiler": "Потім поверніть кількість елементів у `nums`, які не дорівнюють `val`.  \n Розглянемо кількість елементів у `nums`, які не дорівнюють `val`, `k`. Щоб бути прийнятими, вам потрібно зробити наступне: \n* Змініть масив `nums` так, щоб перші `k` елементів `nums` містили елементи, які не дорівнюють `val`. Решта елементів `nums` не важливі, як і розмір `nums`. \n* Поверніть k. \n *** \n Написав своє рішення з заміною елементів на велике число, та подальшим сортуванням. Але воно неоптимальне. Подивився Solutions. Там усього за один прохід формується потрібний масив на місці. Фактично кожний елемент перезаписується але за індексом, якому дорівнює лічильник елементів, які не дорівнюють `val`."
        },
        {
            "date": "17.08.2023",
            "type": "successful",
            "title": "Length of Last Word",
            "text": "Дано рядок `s`, що складається зі слів і пробілів, повернути довжину останнього слова в рядку. Слово — це максимальний підрядок, що складається лише з символів, які не є пробілами.",
            "textUnderSpoiler": "### Обмеження: \n* 1 <= s.length <= 10^4^  \n* `s` складається лише з англійських літер і пробілів ' '.\n* У `s` буде принаймні одне слово. \n *** \n    Легка задача. Ідемо у циклі з кінця рядка. Пробіли пропускаємо, не пробіли рахуємо."
        },
        {
            "date": "18.08.2023",
            "type": "problem",
            "title": "Sqrt(x)",
            "text": "Дано невід’ємне ціле число `x`, поверніть квадратний корінь із `x`, округлений вниз до найближчого цілого числа. Повернене ціле число також має бути невід’ємним. Не можна використовувати будь-які вбудовані функції чи оператори експоненти.",
            "textUnderSpoiler": "### Обмеження: \n* 0 <= x <= 2^31^ - 1 \n *** \n Намагався зробити сам. Прочитав про розрахунок приблизного значення для початкового пошуку. Зробив з коррекцією у циклі за кроком 1. Подивився на Solutions. Виявилось, що треба використовувати бінарний пошук. Переробив свою реалізацію. Тепер там є приблизний розрахунок спочатку та бінарний пошук кореня. Поєднання цих підходів прискорює знаходження результату."
        },
        {
            "date": "19.08.2023",
            "type": "successful",
            "title": "Search Insert Position",
            "text": "Маючи відсортований масив різних цілих чисел і цільове значення, поверніть індекс, якщо ціль знайдено. Якщо ні, поверніть індекс там, де він був би, якби його вставили в порядку зростання. Ви повинні написати алгоритм зі складністю виконання `O(log n)`.",
            "textUnderSpoiler":"\n### Приклади: \n* **Input:** `nums = [1,3,5,6], target = 5` \n* **Output:** `2`\n* **Input:** `nums = [1,3,5,6], target = 2` \n* **Output:** `1` \n* **Input:** `nums = [1,3,5,6], target = 7` \n* **Output:** `4` \n### Обмеження:  \n* 1 <= nums.length <= 10^4^ \n* -10^4^ <= nums[i] <= 10^4^ \n* `nums` містить різні значення, відсортовані в порядку зростання. \n* -10^4^ <= target <= 10^4^ \n *** \n Написав функцію бінарного пошуку. Якщо target не знайдено, то повертається індекс куди його можна вставити щоб масив залишився відсортованим."
        }
    ]
}