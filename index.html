<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="./dist/output.css" rel="stylesheet">
    <title>Document</title>
</head>
<body>



  <div class="wrapper max-w-2xl mx-auto pl-3">
    <h3 class="text-center text-lg font-semibold text-gray-900 dark:text-white py-3 border-b border-gray-200 dark:border-gray-700"">
      LeetCode's problems solving TimeLine
    </h3>
    <ol class="relative border-l border-gray-200 dark:border-gray-700">                  
  <li class="mb-10 ml-4">
      <div class="absolute w-3 h-3 bg-gray-200 rounded-full mt-1.5 -left-1.5 border border-white dark:border-gray-900 dark:bg-gray-700"></div>
      <time class="mb-1 text-sm font-normal leading-none text-gray-400 dark:text-gray-500">12.07.2023</time>
      <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Minimum Depth of Binary Tree</h3>
      <p class="mb-4 text-base font-normal text-gray-500 dark:text-gray-400">
        Пошук мінімальної глибини бінарного дерева. 
        Обхід по дереву можливий за алгоритмами DFS (Depth-first search) та BFS (Breadth-first search).
      </p>
      <p id="12.07.2023" style="display: none;" class="mb-4 text-base font-normal text-gray-500 dark:text-gray-400">
        Мінімальна глибина бінарного дерева це відстань від кореня до найближчого листка (це вузел без нащадків). 
        <br/>
        У цій проблемі, з огляду на швідкість пошуку рішення, краще використати BFS.
      </p>
      <button 
        tittle="Show more" 
        class="inline-flex items-center px-4 py-2 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-lg hover:bg-gray-100 hover:text-blue-700 focus:z-10 focus:ring-4 focus:outline-none focus:ring-gray-200 focus:text-blue-700 dark:bg-gray-800 dark:text-gray-400 dark:border-gray-600 dark:hover:text-white dark:hover:bg-gray-700 dark:focus:ring-gray-700"
        onclick="if(document.getElementById('12.07.2023').style.display=='none') {document.getElementById('12.07.2023').style.display=''}else{document.getElementById('12.07.2023').style.display='none'}"
      >Show/hide</button>
  </li>
  <li class="mb-10 ml-4">
      <div class="absolute w-3 h-3 bg-gray-200 rounded-full mt-1.5 -left-1.5 border border-white dark:border-gray-900 dark:bg-gray-700"></div>
      <time class="mb-1 text-sm font-normal leading-none text-gray-400 dark:text-gray-500">13.07.2023</time>
      <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Check if Object Instance of Class</h3>
      <p class="mb-4 text-base font-normal text-gray-500 dark:text-gray-400">
        Напишіть функцію, яка перевіряє, чи дане значення є екземпляром даного класу або суперкласу. 
        Для цієї проблеми об’єкт вважається екземпляром даного класу, якщо цей об’єкт має доступ до
        методів цього класу.
      </p>
      <p id="13.07.2023" style="display: none;" class="mb-4 text-base font-normal text-gray-500 dark:text-gray-400">
        Цікава проблема, вбудованого instanceof недостатньо. В алгоритмі перевірки використовується 
        конструктор об'єкту. 
      </p>
      <button 
        tittle="Show more" 
        class="inline-flex items-center px-4 py-2 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-lg hover:bg-gray-100 hover:text-blue-700 focus:z-10 focus:ring-4 focus:outline-none focus:ring-gray-200 focus:text-blue-700 dark:bg-gray-800 dark:text-gray-400 dark:border-gray-600 dark:hover:text-white dark:hover:bg-gray-700 dark:focus:ring-gray-700"
        onclick="if(document.getElementById('13.07.2023').style.display=='none') {document.getElementById('13.07.2023').style.display=''}else{document.getElementById('13.07.2023').style.display='none'}"
      >Show/hide</button>
  <li class="mb-10 ml-4">
      <div class="absolute w-3 h-3 bg-gray-200 rounded-full mt-1.5 -left-1.5 border border-white dark:border-gray-900 dark:bg-gray-700"></div>
      <time class="mb-1 text-sm font-normal leading-none text-gray-400 dark:text-gray-500">14.07.2023</time>
      <h3 class="text-lg font-semibold text-gray-900 dark:text-white">Longest Arithmetic Subsequence of Given Difference</h3>
      <p class="mb-4 text-base font-normal text-gray-500 dark:text-gray-400">
        Не одразу зрозуміло що саме треба шукати. Це не підрядок. 
        Підпослідовність це як окремі елементи з похідного масиву, 
        які тільки у тому самому порядку йдуть, та відповідають заданим умовам.
      </p>
      <p id="14.07.2023" style="display: none;" class="mb-4 text-base font-normal text-gray-500 dark:text-gray-400">
        У цій проблемі це - різниця - ціле число на яке зростають/зменшуються 
        числа у підпослідовності. Треба повернути довжину найбільшої підпослідовності.
      </p>
      <button 
        tittle="Show more" 
        class="inline-flex items-center px-4 py-2 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-lg hover:bg-gray-100 hover:text-blue-700 focus:z-10 focus:ring-4 focus:outline-none focus:ring-gray-200 focus:text-blue-700 dark:bg-gray-800 dark:text-gray-400 dark:border-gray-600 dark:hover:text-white dark:hover:bg-gray-700 dark:focus:ring-gray-700"
        onclick="if(document.getElementById('14.07.2023').style.display=='none') {document.getElementById('14.07.2023').style.display=''}else{document.getElementById('14.07.2023').style.display='none'}"
      >Show/hide</button>
  </li>
  <li class="mb-10 ml-4">
    <div class="absolute w-3 h-3 bg-gray-200 rounded-full mt-1.5 -left-1.5 border border-white dark:border-gray-900 dark:bg-gray-700"></div>
    <time class="mb-1 text-sm font-normal leading-none text-gray-400 dark:text-gray-500">15.07.2023</time>
    <h3 class="text-lg font-semibold text-gray-900 dark:text-white">All Nodes Distance K in Binary Tree</h3>
    <p class="mb-4 text-base font-normal text-gray-500 dark:text-gray-400">
      Маючи корінь бінарного дерева, значення цільового вузла та ціле число k, 
      поверніть масив значень усіх вузлів, які мають відстань k від цільового вузла.
    </p>
    <p id="15.07.2023" style="display: none;" class="mb-4 text-base font-normal text-gray-500 dark:text-gray-400">
      Цікава проблема, яку не зовсім зрозуміло як вирішувати. 
      Є найпростіший спосіб з додаванням зворотних зв'язків з батьківським елементом для 
      зворотнього руху по дереву, але цей підхід вважається поганою практикою. 
      Рекомендують робити всеспрямований граф і вже з ним працювати. 
      Почати з target-елемента рекурсивно викликати BFS з передаванням глибини на 1 менше. 
      І так доки глибина не дійде до нуля. Знайдені елементи заносятся до 
      масиву результата.
    </p>
    <button 
      tittle="Show more" 
      class="inline-flex items-center px-4 py-2 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-lg hover:bg-gray-100 hover:text-blue-700 focus:z-10 focus:ring-4 focus:outline-none focus:ring-gray-200 focus:text-blue-700 dark:bg-gray-800 dark:text-gray-400 dark:border-gray-600 dark:hover:text-white dark:hover:bg-gray-700 dark:focus:ring-gray-700"
      onclick="if(document.getElementById('15.07.2023').style.display=='none') {document.getElementById('15.07.2023').style.display=''}else{document.getElementById('15.07.2023').style.display='none'}"
    >Show/hide</button>
</li>

</ol>

  </div>

    
    









  <div class="flex flex-col max-w-2xl mx-auto">
    <div>
      <h1 class = "p-5 text-3xl font-bold underline"> 
        LeetCode's problems solving log
      </h1>
    </div>
    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl shadow-xl bg-sky-500 text-white ">
        12.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-2xl flex items-center space-x-4">
        <div class="shrink-0">
          <svg viewBox="0 0 306 306" width="20" title="check">
            <path fill="#3ca500" d="M152.502,0.001C68.412,0.001,0,68.412,0,152.501s68.412,152.5,152.502,152.5c84.089,0,152.5-68.411,152.5-152.5
			               S236.591,0.001,152.502,0.001z M152.502,280.001C82.197,280.001,25,222.806,25,152.501c0-70.304,57.197-127.5,127.502-127.5
			               c70.304,0,127.5,57.196,127.5,127.5C280.002,222.806,222.806,280.001,152.502,280.001z"/>
		        <path fill="#3ca500" d="M218.473,93.97l-90.546,90.547l-41.398-41.398c-4.882-4.881-12.796-4.881-17.678,0c-4.881,4.882-4.881,12.796,0,17.678
			               l50.237,50.237c2.441,2.44,5.64,3.661,8.839,3.661c3.199,0,6.398-1.221,8.839-3.661l99.385-99.385
			               c4.881-4.882,4.881-12.796,0-17.678C231.269,89.089,223.354,89.089,218.473,93.97z"/>
          </svg>
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">Minimum Depth of Binary Tree</div>
          <p class="p-2 text-slate-500">
            Пошук мінімальної глибини бінарного дерева. 
            Обхід по дереву можливий за алгоритмами DFS (Depth-first search) та BFS (Breadth-first search). 
            Мінімальна глибина бінарного дерева це відстань від кореня до найближчого листка (це вузел без нащадків). 
            <br/>
            У цій проблемі, з огляду на швідкість пошуку рішення, краще використати BFS.
          </p>
        </div>
      </div>
    </div>

    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl bg-sky-500 shadow-xl text-white ">
        13.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4">
        <div class="shrink-0">
          <img class="h-6 w-6" src="./img/check_mark.png" alt="Check Mark Logo">
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">Check if Object Instance of Class</div>
          <p class="p-2 text-slate-500">
            Напишіть функцію, яка перевіряє, чи дане значення є екземпляром даного класу або суперкласу. 
            Для цієї проблеми об’єкт вважається екземпляром даного класу, якщо цей об’єкт має доступ до
            методів цього класу.
            <br/>
            Цікава проблема, вбудованого instanceof недостатньо. В алгоритмі перевірки використовується 
            конструктор об'єкту. 
          </p>
        </div>
      </div>
    </div>

    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl bg-sky-500 shadow-xl text-white ">
        14.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4">
        <div class="shrink-0">
          <img class="h-6 w-6" src="./img/check_mark.png" alt="Check Mark Logo">
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">Longest Arithmetic Subsequence of Given Difference</div>
          <p class="p-2 text-slate-500">
            Не одразу зрозуміло що саме треба шукати. Це не підрядок. 
            Підпослідовність це як окремі елементи з похідного масиву, 
            які тільки у тому самому порядку йдуть, та відповідають заданим умовам. 
            <br/>
            У цій проблемі це - різниця - ціле число на яке зростають/зменшуються 
            числа у підпослідовності. Треба повернути довжину найбільшої підпослідовності.
          </p>
        </div>
      </div>
    </div>

    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl bg-sky-500 shadow-xl text-white ">
        15.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4">
        <div class="shrink-0">
          <img class="h-6 w-6" src="./img/check_mark.png" alt="Check Mark Logo">
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">All Nodes Distance K in Binary Tree</div>
          <p class="p-2 text-slate-500">
            Маючи корінь бінарного дерева, значення цільового вузла та ціле число k, 
            поверніть масив значень усіх вузлів, які мають відстань k від цільового вузла.
            <br/>
            Цікава проблема, яку не зовсім зрозуміло як вирішувати. 
            Є найпростіший спосіб з додаванням зворотних зв'язків з батьківським елементом для 
            зворотнього руху по дереву, але цей підхід вважається поганою практикою. 
            Рекомендують робити всеспрямований граф і вже з ним працювати. 
            Почати з target-елемента рекурсивно викликати BFS з передаванням глибини на 1 менше. 
            І так доки глибина не дійде до нуля. Знайдені елементи заносятся до 
            масиву результата.
          </p>
        </div>
      </div>
    </div>

    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl bg-sky-500 shadow-xl text-white ">
        16.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4">
        <div class="shrink-0">
          <img class="h-6 w-6" src="./img/check_mark.png" alt="Check Mark Logo">
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">Binary Tree Inorder Traversal</div>
          <p class="p-2 text-slate-500">
            Даний корінь бінарного дерева, поверніть упорядкований обхід значень його вузлів.
            <br/>
            Ця проблема легкого рівня. Більш детально розглядаю варіанти обходу дерева.
            Існують такі варіанти:
            <br/>&nbsp - прямий порядок;
            <br/>&nbsp - зворотній порядок;
            <br/>&nbsp - симетричний порядок;
            <br/>&nbsp - зворотньо-симетричний порядок.
            <br/> 
             Варіант обходу залежить від послідовності виклику лівого та правого піддерева, а також звернення до батьківського елементу. 
          </p>
        </div>
      </div>
    </div>

    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl bg-sky-500 shadow-xl text-white ">
        17.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4">
        <div class="shrink-0">
          <img class="h-6 w-6" src="./img/check_mark.png" alt="Check Mark Logo">
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">Add Two Numbers II</div>
          <p class="p-2 text-slate-500">
            У цьому завданні надано два непорожніх пов’язаних списка, 
            що представляють два цілі невід’ємні числа. Найстарша цифра йде першою, 
            і кожен з їхніх вузлів містить одну цифру. Додайте два числа та поверніть суму 
            у вигляді зв’язаного списку.Треба порахувати суму ніби у стовпчик, 
            але кожне число то є одно-спрямований список (не масив). 
            <br/>
            Завдання вирішено з використанням допоміжних стеків для обох списків, 
            тому що обхід та формування суми треба розпочинати з наймолодших цифр.
          </p>
        </div>
      </div>
    </div>

    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl bg-sky-500 shadow-xl text-white ">
        18.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4">
        <div class="shrink-0">
          <img class="h-6 w-6" src="./img/check_mark.png" alt="Check Mark Logo">
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">LRU Cache</div>
          <p class="p-2 text-slate-500">
            Створіть структуру даних, яка відповідає характеристикам кешу,
            що останнім часом використовувався (LRU).
            <br/>
            Тут ідея в тому, що кеш має якийсь ліміт за розміром, 
            тому спочатку він наповнюється елементами, потім треба,
            перед додаванням нового елементу, знайти який з попередніх 
            був довше за усіх непотрібний, та видалити його. 
            У реалізації алгоритму використаний об'єкт Map (асоціативний масив). 
            Кожного разу, коли йде звернення до кешу, послідовність елементів змінюється. 
            Той елемент, до якого був доступ чи новий доданий переміщується у кінець кешу. 
            Коли кеш набуває лімітованого розміру, тоді додатково на початку кешу буде 
            видалятися "найстаріший" елемент, коли треба додати новий елемент.
          </p>
        </div>
      </div>
    </div>

    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl bg-sky-500 shadow-xl text-white ">
        19.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4">
        <div class="shrink-0">
          <img class="h-6 w-6" src="./img/check_mark.png" alt="Check Mark Logo">
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">Non-overlapping Intervals</div>
          <p class="p-2 text-slate-500">
            Інтервали, що не перекриваються.
            <br/>
            Дано масив інтервалів intervals, де intervals[i] = [start_i, end_i], 
            поверніть мінімальну кількість інтервалів, які потрібно видалити, 
            щоб решта інтервалів не перекривалася.
            <br/>
            Проблема medium-рівня, яку одразу і не зрозуміло як вирішувати. 
            Подивився editorial. Це відома проблема інтервального планування, 
            яка дуже часто зустрічається у програмуванні та добре описана. 
            Проблема максимізації інтервального планування (ISMP) полягає в тому, 
            щоб знайти найбільший сумісний набір, тобто набір непересічних 
            інтервалів максимального розміру. Мета тут полягає в тому, 
            щоб виконати якомога більше завдань, тобто максимізувати пропускну здатність. 
            Це еквівалентно знаходженню максимального незалежного набору в інтервальному графі.
            Алгоритм який запропонований досить простий. 
            Інтервали спочатку сортуються по часу закінчення за зростанням. 
            Потім у циклі шукається найкоротші інтервали, які ідуть без перекривання, 
            усі інші які перекриваються, рахуються та їх сума повертаються у вигляді відповіді.
          </p>
        </div>
      </div>
    </div>

    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl bg-sky-500 shadow-xl text-white ">
        20.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4">
        <div class="shrink-0">
          <img class="h-6 w-6" src="./img/check_mark.png" alt="Check Mark Logo">
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">Asteroid Collision</div>
          <p class="p-2 text-slate-500">
            Зіткнення астероїдів. 
            <br/>
            Нам надано масив астероїдів цілих чисел, що представляють астероїди в рядку. 
            Для кожного астероїда абсолютне значення представляє його розмір, 
            а знак — його напрямок (позитивне означає праворуч, негативне значення — ліворуч). 
            Кожен астероїд рухається з однаковою швидкістю. 
            Дізнайтеся стан астероїдів після всіх зіткнень. 
            Якщо два астероїди зустрінуться, менший з них вибухне. 
            Якщо обидва мають однаковий розмір, обидва вибухнуть. 
            Два астероїди, що рухаються в одному напрямку, ніколи не зустрінуться.
            <br/>
            Цікава проблема. Я не став нічого вигадувати і подивися editorial. 
            Дуже хитрий алгоритм. Рішення полягає у роботі з допоміжним масивом або стеком, 
            до якого заносяться ті астероїди, що слід обробити. 
            Далі вони послідовно порівнюються з іншими астероїдами та 
            визначається чи залишится він у стеку або він "вибухне". 
            Кожен астероїд порівнюється з кожним іншим рівно один раз. 
            Після цього результуючий стек чи масив вважається готовим.
          </p>
        </div>
      </div>
    </div>

    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl bg-sky-500 shadow-xl text-white ">
        21.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4">
        <div class="shrink-0">
          <img class="h-6 w-6" src="./img/check_mark.png" alt="Check Mark Logo">
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">Number of Longest Increasing Subsequence</div>
          <p class="p-2 text-slate-500">
            Кількість найдовших зростаючих підпослідовностей.
            <br/>
            Перш ніж спробувати вирішити цю задачу, дуже рекомендують, 
            спочатку розв’язати найдовшу зростаючу підпослідовність, 
            до якої ця задача є продовженням. Але я з нею ще не стикався. 
            Рішення я подивився в editorial, так і не зрозумів його, та просто переписав наведений код у JS.
          </p>
        </div>
      </div>
    </div>

    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl bg-sky-500 shadow-xl text-white ">
        22.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4">
        <div class="shrink-0">
          <img class="h-6 w-6" src="./img/check_mark.png" alt="Check Mark Logo">
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">Find the Index of the First Occurrence in a String</div>
          <p class="p-2 text-slate-500">
            Знайдти індекс першого входження в рядок.
            <br/>
            Дано два рядки needle і haystack, поверніть індекс першого 
            входження needle у haystack або -1, якщо needle не є частиною haystack.
            <br/>
            Звичайно у JS є метод string.prototype.indexOf(subStr). 
            Але схоже треба зробити свою реалізацію. Я написав, потім ще 
            трохи переробив алгоритм, але мабуть не зовсім те що треба.
            Орієнтуватися треба на такі оптимальні алгоритми:
            <br/> &nbsp - <a class="font-bold underline" href="http://en.wikipedia.org/wiki/Boyer-Moore_string_search_algorithm"> Boyer-Moore</a> 
            uses a bad character table with a good suffix table.
            <br/> &nbsp - <a class="font-bold underline" href="http://en.wikipedia.org/wiki/Boyer-Moore-Horspool_algorithm">Boyer-Moore-Horspool</a> 
            uses a bad character table.
            <br/> &nbsp - <a class="font-bold underline" href="http://en.wikipedia.org/wiki/Knuth-Morris-Pratt_algorithm">Knuth-Morris-Pratt</a> 
            uses a partial match table.
            <br/> &nbsp - <a class="font-bold underline" href="http://en.wikipedia.org/wiki/Rabin-Karp_string_search_algorithm">Rabin-Karp </a>
            uses running hashes
            <br/>
            Спробував реалізувати Boyer-Moore-Horspool, але схоже що він краще працює на C ніж yf JS.
          </p>
        </div>
      </div>
    </div>

    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl bg-sky-500 shadow-xl text-white ">
        24.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4">
        <div class="shrink-0">
          <img class="h-6 w-6" src="./img/check_mark.png" alt="Check Mark Logo">
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">Merge Two Sorted Lists</div>
          <p class="p-2 text-slate-500">
            Об’єднати два відсортовані списки.
            <br/>
            Вам надано заголовки двох відсортованих пов’язаних списків list1 і list2. 
            Об’єднайте два списки в один відсортований список. 
            Список має бути створений шляхом з’єднання вузлів перших двох списків. 
            Поверніть заголовок об’єднаного зв’язаного списку.
            <br/>
            Є реалізація, але дуже повільна і пам'ять жере. Треба зробити якось без new. 
            Подивився як роблять інші - різні підходи є. Мені сподобався варіант,
            де просто з двох списків формується один результуючий, при цьому нові вузли не створюються.
          </p>
        </div>
      </div>
    </div>

    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl bg-sky-500 shadow-xl text-white ">
        25.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4">
        <div class="shrink-0">
          <img class="h-6 w-6" src="./img/check_mark.png" alt="Check Mark Logo">
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">Merge k Sorted Lists</div>
          <p class="p-2 text-slate-500">
            Об’єднати k відсортованих списків
            <br/>
            Вам надано масив із k зв’язаних списків, кожен зв’язаний список 
            відсортований у порядку зростання. Об’єднайте всі зв’язані списки 
            в один відсортований зв’язаний список і поверніть його. 
            <br/>
            Проблема рівня hard. Спробував зробити для k списків приблизно за 
            учорашнім алгоритмом, але попередньо сортуючи списки за значенням val 
            перших елементів. Працює, але ну дуже повільно. Дуже багато разів 
            іде сортування. Подивився що у інших, який там самий швидкий алгоритм. 
            <br/>
            Виявилося, що можна було всі елементи списків запушити у масив 
            (елемент масива це об'єкт з полями val та next). Потім цей весь масив 
            один раз сортується за значеннями val. Потім цей масив перетворюється 
            у список. При цьому правильно виставляються поля next у кожного елемента
            з масиву. У фіналі оформлюється tail, та повертається нульовий елемент масиву (як head).
          </p>
        </div>
      </div>
    </div>

    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl bg-sky-500 shadow-xl text-white ">
        26.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4">
        <div class="shrink-0">
          <img class="h-6 w-6" src="./img/check_mark.png" alt="Check Mark Logo">
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">Merge Sorted Array</div>
          <p class="p-2 text-slate-500">
            Задача об'єднати два неубиваючі масиви розміром m+n та n. 
            У першому масиві останні n елементів заповнені 0.
            <br/>
            Задачу спочатку вирішив як найпростіше - другий скопіював 
            у кінець першого, а потім відсортував. Але це не оптимальний підхід. 
            Щоб складність була O(m + n) треба піти іншим шляхом. 
            Почати с кінця першого масива формувати одразу відсортований, 
            шляхом порівняння елементів з першого та другого масивів. 
            Таким шляхом за один прохід по масиву буде сформовано результуючий неубиваючий масив.
          </p>
        </div>
      </div>
    </div>

    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl bg-sky-500 shadow-xl text-white ">
        27.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4">
        <div class="shrink-0">
          <img class="h-6 w-6" src="./img/check_mark.png" alt="Check Mark Logo">
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">Maximum Running Time of N Computers</div>
          <p class="p-2 text-slate-500">
            Максимальний час роботи N комп’ютерів - задача на разрахунок
            максимального часу n ноутбуків від m (m >= n) батарей акумуляторів. 
            Треба прорахувати на скільки вистачить усіх батарей, 
            якщо їх швидко замінювати у комп'ютерах. 
            Ввважається що час заміни невідчутно малий.
            <br/>
            Задача цікава (особливо від час блекаутів). 
            Я початку спробував просто вирахувати загальну кількість годин роботи 
            (заряду) зі всіх батарей, та розділити на кількість комп'ютерів, 
            результат округлив до меншого цілого. Але тест кейси деякі не проходили. 
            Стало ясно що не завжди можливо замінити батарею, тому треба якось перевіряти 
            чи можнаа так розставити батареї, щоб усі компи одночасно працювали. 
            Подивився editorial, там якій не дуже зрозумілі підходи та алгоритми, 
            повторити які не вдалося, бо там використовувся тип long, 
            а у мене в JS викидало помилку. 
            <br/>
            Але коли я почав дивитися просто чиїсь готові рішення мене вразило, 
            на скільки просто ця задача розв'язувалася. Дуже просте рішеня полягало в тому, 
            що спочатку масив з батареями сортували, потім у циклі робили перевірку, 
            якщо ємність одної з батареї перевищувала середню ємність на один комп'ютер, 
            то таку батерею відкидали (із масиву) і комп'ютер в якому вона буде працювати теж, 
            та перераховували середню ємність на компьютер. І так до тих пір, 
            поки ємність останньої батареї не стає рівною або менше за перераховану 
            середню ємність. Саме її і слід повернути як результат.
          </p>
        </div>
      </div>
    </div>

    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl bg-sky-500 shadow-xl text-white ">
        28.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4">
        <div class="shrink-0">
          <img class="h-6 w-6" src="./img/check_mark.png" alt="Check Mark Logo">
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">Predict the Winner</div>
          <p class="p-2 text-slate-500">
            Передбачте переможця
            <br/>
            Вам надано цілочисельний масив nums. Два гравці грають 
            у гру з цим масивом: гравець 1 і гравець 2. 
            Гравець 1 і гравець 2 по черзі, причому гравець 1 починає першим. 
            Обидва гравці починають гру з результатом 0. Кожного ходу гравець 
            бере одне з чисел з обох кінців масиву (тобто nums[0] або nums[nums.length - 1]), 
            що зменшує розмір масиву на 1. Гравець додає вибране число до свого рахунку. 
            Гра закінчується, коли в масиві більше немає елементів. 
            Поверніть true, якщо Гравець 1 може виграти гру. 
            Якщо бали обох гравців однакові, тоді гравець 1 все ще є переможцем, 
            і ви також повинні повернути true. Ви можете припустити, що обидва гравці грають оптимально.
            <br/>
            Завдання medium рівня. І я не знав як робити. Подивився в editorial. 
            Перші два підходи спробував запустити. Другий більш оптимальний, 
            тому що часткові результати обчислень зберігаються у кеші. 
            Сама ідея у тому, що рекурсивно викликається функцція maxDiff(), 
            яка обчислює скільки балів отримає гравець на рахунок. При цьому звісно 
            "гравець точно розраховує скількі балів він отримує в кінці гри, та робить 
            тільки вигідний для нього хід". Отже maxDiff отримує два аргументи left та right
            - це індекси з початку та кінця масиву. А у середені функції обчислюється 
            обидва варіанти ходу та знову викликається для обох варіантів maxDiff. 
            Рекурсія припиняється коли масив з балами звужується до одного числа. 
            Але схоже, що цей алгоритм я так і не зрозумів. Логіка мені до кінця не зрозуміла.
          </p>
        </div>
      </div>
    </div>

    <div class="m-5">
      <p class="p-1 max-w-fit my-2 rounded-xl bg-sky-500 shadow-xl text-white ">
        29.07.2023
      </p>
      <div class="p-6 mx-auto bg-white rounded-xl shadow-lg flex items-center space-x-4">
        <div class="shrink-0">
          <img class="h-6 w-6" src="./img/check_mark.png" alt="Check Mark Logo">
        </div>
        <div>
          <div class="p-2 text-xl font-medium text-black">Maximum Product Subarray</div>
          <p class="p-2 text-slate-500">
            Максимальний підмасив добутку.
            <br/>
            Дано цілочисельний масив nums, знайти підмасив із найбільшим 
            добутком і повернути добуток. Тестові приклади генеруються таким чином, 
            що відповідь поміщається в 32-розрядне ціле число.
            <br/>
            Цікава задача, я її вирішив і знову геть не оптимально. 
            Подивився, що люди пропонують. І той варіант мені сподобався. 
            За один прохід (O(n)) результат обчислюється. Треба було пройти по масиву, 
            обчислюючи поточний максимум та поточний мінімум (для від'ємних результатів). 
            Вони також використовуються для обчислення самих себе але при наступній ітерації. 
            Якщо поточний максимум перевищить загальний результат, 
            то загальний результат переприсвоюється.
          </p>
        </div>
      </div>
    </div>





  </div>

</body>
</html>